/**
 *
 *  MaterialBudgetItems.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */

#include "MaterialBudgetItems.h"
#include <drogon/utils/Utilities.h>
#include <string>

using namespace drogon;
using namespace drogon_model::openproject4;

const std::string MaterialBudgetItems::Cols::_id = "id";
const std::string MaterialBudgetItems::Cols::_cost_object_id = "cost_object_id";
const std::string MaterialBudgetItems::Cols::_units = "units";
const std::string MaterialBudgetItems::Cols::_cost_type_id = "cost_type_id";
const std::string MaterialBudgetItems::Cols::_comments = "comments";
const std::string MaterialBudgetItems::Cols::_budget = "budget";
const std::string MaterialBudgetItems::primaryKeyName = "id";
const bool MaterialBudgetItems::hasPrimaryKey = true;
const std::string MaterialBudgetItems::tableName = "material_budget_items";

const std::vector<typename MaterialBudgetItems::MetaData> MaterialBudgetItems::_metaData={
{"id","int32_t","integer",4,1,1,1},
{"cost_object_id","int32_t","integer",4,0,0,1},
{"units","double","double precision",8,0,0,1},
{"cost_type_id","int32_t","integer",4,0,0,0},
{"comments","std::string","character varying",0,0,0,1},
{"budget","int64_t","numeric",8,0,0,0}
};
const std::string &MaterialBudgetItems::getColumnName(size_t index) noexcept(false)
{
    assert(index < _metaData.size());
    return _metaData[index]._colName;
}
MaterialBudgetItems::MaterialBudgetItems(const Row &r) noexcept
{
        if(!r["id"].isNull())
        {
            _id=std::make_shared<int32_t>(r["id"].as<int32_t>());
        }
        if(!r["cost_object_id"].isNull())
        {
            _costObjectId=std::make_shared<int32_t>(r["cost_object_id"].as<int32_t>());
        }
        if(!r["units"].isNull())
        {
            _units=std::make_shared<double>(r["units"].as<double>());
        }
        if(!r["cost_type_id"].isNull())
        {
            _costTypeId=std::make_shared<int32_t>(r["cost_type_id"].as<int32_t>());
        }
        if(!r["comments"].isNull())
        {
            _comments=std::make_shared<std::string>(r["comments"].as<std::string>());
        }
        if(!r["budget"].isNull())
        {
            _budget=std::make_shared<int64_t>(r["budget"].as<int64_t>());
        }
}
const int32_t &MaterialBudgetItems::getValueOfId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_id)
        return *_id;
    return defaultValue;
}
const std::shared_ptr<int32_t> &MaterialBudgetItems::getId() const noexcept
{
    return _id;
}
const typename MaterialBudgetItems::PrimaryKeyType & MaterialBudgetItems::getPrimaryKey() const
{
    assert(_id);
    return *_id;
}

const int32_t &MaterialBudgetItems::getValueOfCostObjectId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_costObjectId)
        return *_costObjectId;
    return defaultValue;
}
const std::shared_ptr<int32_t> &MaterialBudgetItems::getCostObjectId() const noexcept
{
    return _costObjectId;
}
void MaterialBudgetItems::setCostObjectId(const int32_t &pCostObjectId) noexcept
{
    _costObjectId = std::make_shared<int32_t>(pCostObjectId);
    _dirtyFlag[1] = true;
}


const double &MaterialBudgetItems::getValueOfUnits() const noexcept
{
    const static double defaultValue = double();
    if(_units)
        return *_units;
    return defaultValue;
}
const std::shared_ptr<double> &MaterialBudgetItems::getUnits() const noexcept
{
    return _units;
}
void MaterialBudgetItems::setUnits(const double &pUnits) noexcept
{
    _units = std::make_shared<double>(pUnits);
    _dirtyFlag[2] = true;
}


const int32_t &MaterialBudgetItems::getValueOfCostTypeId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_costTypeId)
        return *_costTypeId;
    return defaultValue;
}
const std::shared_ptr<int32_t> &MaterialBudgetItems::getCostTypeId() const noexcept
{
    return _costTypeId;
}
void MaterialBudgetItems::setCostTypeId(const int32_t &pCostTypeId) noexcept
{
    _costTypeId = std::make_shared<int32_t>(pCostTypeId);
    _dirtyFlag[3] = true;
}


const std::string &MaterialBudgetItems::getValueOfComments() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_comments)
        return *_comments;
    return defaultValue;
}
const std::shared_ptr<std::string> &MaterialBudgetItems::getComments() const noexcept
{
    return _comments;
}
void MaterialBudgetItems::setComments(const std::string &pComments) noexcept
{
    _comments = std::make_shared<std::string>(pComments);
    _dirtyFlag[4] = true;
}
void MaterialBudgetItems::setComments(std::string &&pComments) noexcept
{
    _comments = std::make_shared<std::string>(std::move(pComments));
    _dirtyFlag[4] = true;
}


const int64_t &MaterialBudgetItems::getValueOfBudget() const noexcept
{
    const static int64_t defaultValue = int64_t();
    if(_budget)
        return *_budget;
    return defaultValue;
}
const std::shared_ptr<int64_t> &MaterialBudgetItems::getBudget() const noexcept
{
    return _budget;
}
void MaterialBudgetItems::setBudget(const int64_t &pBudget) noexcept
{
    _budget = std::make_shared<int64_t>(pBudget);
    _dirtyFlag[5] = true;
}


void MaterialBudgetItems::updateId(const uint64_t id)
{
}

const std::vector<std::string> &MaterialBudgetItems::insertColumns() noexcept
{
    static const std::vector<std::string> _inCols={
        "cost_object_id",
        "units",
        "cost_type_id",
        "comments",
        "budget"
    };
    return _inCols;
}

void MaterialBudgetItems::outputArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(getCostObjectId())
    {
        binder << getValueOfCostObjectId();
    }
    else
    {
        binder << nullptr;
    }
    if(getUnits())
    {
        binder << getValueOfUnits();
    }
    else
    {
        binder << nullptr;
    }
    if(getCostTypeId())
    {
        binder << getValueOfCostTypeId();
    }
    else
    {
        binder << nullptr;
    }
    if(getComments())
    {
        binder << getValueOfComments();
    }
    else
    {
        binder << nullptr;
    }
    if(getBudget())
    {
        binder << getValueOfBudget();
    }
    else
    {
        binder << nullptr;
    }
}

const std::vector<std::string> MaterialBudgetItems::updateColumns() const
{
    std::vector<std::string> ret;
    for(size_t i=0;i<sizeof(_dirtyFlag);i++)
    {
        if(_dirtyFlag[i])
        {
            ret.push_back(getColumnName(i));
        }
    }
    return ret;
}

void MaterialBudgetItems::updateArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(_dirtyFlag[1])
    {
        if(getCostObjectId())
        {
            binder << getValueOfCostObjectId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[2])
    {
        if(getUnits())
        {
            binder << getValueOfUnits();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[3])
    {
        if(getCostTypeId())
        {
            binder << getValueOfCostTypeId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[4])
    {
        if(getComments())
        {
            binder << getValueOfComments();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[5])
    {
        if(getBudget())
        {
            binder << getValueOfBudget();
        }
        else
        {
            binder << nullptr;
        }
    }
}
Json::Value MaterialBudgetItems::toJson() const
{
    Json::Value ret;
    if(getId())
    {
        ret["id"]=getValueOfId();
    }
    else
    {
        ret["id"]=Json::Value();
    }
    if(getCostObjectId())
    {
        ret["cost_object_id"]=getValueOfCostObjectId();
    }
    else
    {
        ret["cost_object_id"]=Json::Value();
    }
    if(getUnits())
    {
        ret["units"]=getValueOfUnits();
    }
    else
    {
        ret["units"]=Json::Value();
    }
    if(getCostTypeId())
    {
        ret["cost_type_id"]=getValueOfCostTypeId();
    }
    else
    {
        ret["cost_type_id"]=Json::Value();
    }
    if(getComments())
    {
        ret["comments"]=getValueOfComments();
    }
    else
    {
        ret["comments"]=Json::Value();
    }
    if(getBudget())
    {
        ret["budget"]=(Json::Int64)getValueOfBudget();
    }
    else
    {
        ret["budget"]=Json::Value();
    }
    return ret;
}
