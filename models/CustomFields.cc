/**
 *
 *  CustomFields.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */

#include "CustomFields.h"
#include <drogon/utils/Utilities.h>
#include <string>

using namespace drogon;
using namespace drogon_model::openproject4;

const std::string CustomFields::Cols::_id = "id";
const std::string CustomFields::Cols::_type = "type";
const std::string CustomFields::Cols::_field_format = "field_format";
const std::string CustomFields::Cols::_regexp = "regexp";
const std::string CustomFields::Cols::_min_length = "min_length";
const std::string CustomFields::Cols::_max_length = "max_length";
const std::string CustomFields::Cols::_is_required = "is_required";
const std::string CustomFields::Cols::_is_for_all = "is_for_all";
const std::string CustomFields::Cols::_is_filter = "is_filter";
const std::string CustomFields::Cols::_position = "position";
const std::string CustomFields::Cols::_searchable = "searchable";
const std::string CustomFields::Cols::_editable = "editable";
const std::string CustomFields::Cols::_visible = "visible";
const std::string CustomFields::Cols::_multi_value = "multi_value";
const std::string CustomFields::Cols::_default_value = "default_value";
const std::string CustomFields::Cols::_name = "name";
const std::string CustomFields::Cols::_created_at = "created_at";
const std::string CustomFields::Cols::_updated_at = "updated_at";
const std::string CustomFields::primaryKeyName = "id";
const bool CustomFields::hasPrimaryKey = true;
const std::string CustomFields::tableName = "custom_fields";

const std::vector<typename CustomFields::MetaData> CustomFields::_metaData={
{"id","int32_t","integer",4,1,1,1},
{"type","std::string","character varying",30,0,0,1},
{"field_format","std::string","character varying",30,0,0,1},
{"regexp","std::string","character varying",0,0,0,0},
{"min_length","int32_t","integer",4,0,0,1},
{"max_length","int32_t","integer",4,0,0,1},
{"is_required","bool","boolean",1,0,0,1},
{"is_for_all","bool","boolean",1,0,0,1},
{"is_filter","bool","boolean",1,0,0,1},
{"position","int32_t","integer",4,0,0,0},
{"searchable","bool","boolean",1,0,0,0},
{"editable","bool","boolean",1,0,0,0},
{"visible","bool","boolean",1,0,0,1},
{"multi_value","bool","boolean",1,0,0,0},
{"default_value","std::string","text",0,0,0,0},
{"name","std::string","character varying",255,0,0,0},
{"created_at","::trantor::Date","timestamp without time zone",0,0,0,0},
{"updated_at","::trantor::Date","timestamp without time zone",0,0,0,0}
};
const std::string &CustomFields::getColumnName(size_t index) noexcept(false)
{
    assert(index < _metaData.size());
    return _metaData[index]._colName;
}
CustomFields::CustomFields(const Row &r) noexcept
{
        if(!r["id"].isNull())
        {
            _id=std::make_shared<int32_t>(r["id"].as<int32_t>());
        }
        if(!r["type"].isNull())
        {
            _type=std::make_shared<std::string>(r["type"].as<std::string>());
        }
        if(!r["field_format"].isNull())
        {
            _fieldFormat=std::make_shared<std::string>(r["field_format"].as<std::string>());
        }
        if(!r["regexp"].isNull())
        {
            _regexp=std::make_shared<std::string>(r["regexp"].as<std::string>());
        }
        if(!r["min_length"].isNull())
        {
            _minLength=std::make_shared<int32_t>(r["min_length"].as<int32_t>());
        }
        if(!r["max_length"].isNull())
        {
            _maxLength=std::make_shared<int32_t>(r["max_length"].as<int32_t>());
        }
        if(!r["is_required"].isNull())
        {
            _isRequired=std::make_shared<bool>(r["is_required"].as<bool>());
        }
        if(!r["is_for_all"].isNull())
        {
            _isForAll=std::make_shared<bool>(r["is_for_all"].as<bool>());
        }
        if(!r["is_filter"].isNull())
        {
            _isFilter=std::make_shared<bool>(r["is_filter"].as<bool>());
        }
        if(!r["position"].isNull())
        {
            _position=std::make_shared<int32_t>(r["position"].as<int32_t>());
        }
        if(!r["searchable"].isNull())
        {
            _searchable=std::make_shared<bool>(r["searchable"].as<bool>());
        }
        if(!r["editable"].isNull())
        {
            _editable=std::make_shared<bool>(r["editable"].as<bool>());
        }
        if(!r["visible"].isNull())
        {
            _visible=std::make_shared<bool>(r["visible"].as<bool>());
        }
        if(!r["multi_value"].isNull())
        {
            _multiValue=std::make_shared<bool>(r["multi_value"].as<bool>());
        }
        if(!r["default_value"].isNull())
        {
            _defaultValue=std::make_shared<std::string>(r["default_value"].as<std::string>());
        }
        if(!r["name"].isNull())
        {
            _name=std::make_shared<std::string>(r["name"].as<std::string>());
        }
        if(!r["created_at"].isNull())
        {
            auto timeStr = r["created_at"].as<std::string>();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            size_t t = timelocal(&stm);
            size_t decimalNum = 0;
            if(*p=='.')
            {
                std::string decimals(p+1,&timeStr[timeStr.length()]);
                while(decimals.length()<6)
                {
                    decimals += "0";
                }
                decimalNum = (size_t)atol(decimals.c_str());
            }
            _createdAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
        }
        if(!r["updated_at"].isNull())
        {
            auto timeStr = r["updated_at"].as<std::string>();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            size_t t = timelocal(&stm);
            size_t decimalNum = 0;
            if(*p=='.')
            {
                std::string decimals(p+1,&timeStr[timeStr.length()]);
                while(decimals.length()<6)
                {
                    decimals += "0";
                }
                decimalNum = (size_t)atol(decimals.c_str());
            }
            _updatedAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
        }
}
const int32_t &CustomFields::getValueOfId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_id)
        return *_id;
    return defaultValue;
}
const std::shared_ptr<int32_t> &CustomFields::getId() const noexcept
{
    return _id;
}
const typename CustomFields::PrimaryKeyType & CustomFields::getPrimaryKey() const
{
    assert(_id);
    return *_id;
}

const std::string &CustomFields::getValueOfType() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_type)
        return *_type;
    return defaultValue;
}
const std::shared_ptr<std::string> &CustomFields::getType() const noexcept
{
    return _type;
}
void CustomFields::setType(const std::string &pType) noexcept
{
    _type = std::make_shared<std::string>(pType);
    _dirtyFlag[1] = true;
}
void CustomFields::setType(std::string &&pType) noexcept
{
    _type = std::make_shared<std::string>(std::move(pType));
    _dirtyFlag[1] = true;
}


const std::string &CustomFields::getValueOfFieldFormat() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_fieldFormat)
        return *_fieldFormat;
    return defaultValue;
}
const std::shared_ptr<std::string> &CustomFields::getFieldFormat() const noexcept
{
    return _fieldFormat;
}
void CustomFields::setFieldFormat(const std::string &pFieldFormat) noexcept
{
    _fieldFormat = std::make_shared<std::string>(pFieldFormat);
    _dirtyFlag[2] = true;
}
void CustomFields::setFieldFormat(std::string &&pFieldFormat) noexcept
{
    _fieldFormat = std::make_shared<std::string>(std::move(pFieldFormat));
    _dirtyFlag[2] = true;
}


const std::string &CustomFields::getValueOfRegexp() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_regexp)
        return *_regexp;
    return defaultValue;
}
const std::shared_ptr<std::string> &CustomFields::getRegexp() const noexcept
{
    return _regexp;
}
void CustomFields::setRegexp(const std::string &pRegexp) noexcept
{
    _regexp = std::make_shared<std::string>(pRegexp);
    _dirtyFlag[3] = true;
}
void CustomFields::setRegexp(std::string &&pRegexp) noexcept
{
    _regexp = std::make_shared<std::string>(std::move(pRegexp));
    _dirtyFlag[3] = true;
}


const int32_t &CustomFields::getValueOfMinLength() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_minLength)
        return *_minLength;
    return defaultValue;
}
const std::shared_ptr<int32_t> &CustomFields::getMinLength() const noexcept
{
    return _minLength;
}
void CustomFields::setMinLength(const int32_t &pMinLength) noexcept
{
    _minLength = std::make_shared<int32_t>(pMinLength);
    _dirtyFlag[4] = true;
}


const int32_t &CustomFields::getValueOfMaxLength() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_maxLength)
        return *_maxLength;
    return defaultValue;
}
const std::shared_ptr<int32_t> &CustomFields::getMaxLength() const noexcept
{
    return _maxLength;
}
void CustomFields::setMaxLength(const int32_t &pMaxLength) noexcept
{
    _maxLength = std::make_shared<int32_t>(pMaxLength);
    _dirtyFlag[5] = true;
}


const bool &CustomFields::getValueOfIsRequired() const noexcept
{
    const static bool defaultValue = bool();
    if(_isRequired)
        return *_isRequired;
    return defaultValue;
}
const std::shared_ptr<bool> &CustomFields::getIsRequired() const noexcept
{
    return _isRequired;
}
void CustomFields::setIsRequired(const bool &pIsRequired) noexcept
{
    _isRequired = std::make_shared<bool>(pIsRequired);
    _dirtyFlag[6] = true;
}


const bool &CustomFields::getValueOfIsForAll() const noexcept
{
    const static bool defaultValue = bool();
    if(_isForAll)
        return *_isForAll;
    return defaultValue;
}
const std::shared_ptr<bool> &CustomFields::getIsForAll() const noexcept
{
    return _isForAll;
}
void CustomFields::setIsForAll(const bool &pIsForAll) noexcept
{
    _isForAll = std::make_shared<bool>(pIsForAll);
    _dirtyFlag[7] = true;
}


const bool &CustomFields::getValueOfIsFilter() const noexcept
{
    const static bool defaultValue = bool();
    if(_isFilter)
        return *_isFilter;
    return defaultValue;
}
const std::shared_ptr<bool> &CustomFields::getIsFilter() const noexcept
{
    return _isFilter;
}
void CustomFields::setIsFilter(const bool &pIsFilter) noexcept
{
    _isFilter = std::make_shared<bool>(pIsFilter);
    _dirtyFlag[8] = true;
}


const int32_t &CustomFields::getValueOfPosition() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_position)
        return *_position;
    return defaultValue;
}
const std::shared_ptr<int32_t> &CustomFields::getPosition() const noexcept
{
    return _position;
}
void CustomFields::setPosition(const int32_t &pPosition) noexcept
{
    _position = std::make_shared<int32_t>(pPosition);
    _dirtyFlag[9] = true;
}


const bool &CustomFields::getValueOfSearchable() const noexcept
{
    const static bool defaultValue = bool();
    if(_searchable)
        return *_searchable;
    return defaultValue;
}
const std::shared_ptr<bool> &CustomFields::getSearchable() const noexcept
{
    return _searchable;
}
void CustomFields::setSearchable(const bool &pSearchable) noexcept
{
    _searchable = std::make_shared<bool>(pSearchable);
    _dirtyFlag[10] = true;
}


const bool &CustomFields::getValueOfEditable() const noexcept
{
    const static bool defaultValue = bool();
    if(_editable)
        return *_editable;
    return defaultValue;
}
const std::shared_ptr<bool> &CustomFields::getEditable() const noexcept
{
    return _editable;
}
void CustomFields::setEditable(const bool &pEditable) noexcept
{
    _editable = std::make_shared<bool>(pEditable);
    _dirtyFlag[11] = true;
}


const bool &CustomFields::getValueOfVisible() const noexcept
{
    const static bool defaultValue = bool();
    if(_visible)
        return *_visible;
    return defaultValue;
}
const std::shared_ptr<bool> &CustomFields::getVisible() const noexcept
{
    return _visible;
}
void CustomFields::setVisible(const bool &pVisible) noexcept
{
    _visible = std::make_shared<bool>(pVisible);
    _dirtyFlag[12] = true;
}


const bool &CustomFields::getValueOfMultiValue() const noexcept
{
    const static bool defaultValue = bool();
    if(_multiValue)
        return *_multiValue;
    return defaultValue;
}
const std::shared_ptr<bool> &CustomFields::getMultiValue() const noexcept
{
    return _multiValue;
}
void CustomFields::setMultiValue(const bool &pMultiValue) noexcept
{
    _multiValue = std::make_shared<bool>(pMultiValue);
    _dirtyFlag[13] = true;
}


const std::string &CustomFields::getValueOfDefaultValue() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_defaultValue)
        return *_defaultValue;
    return defaultValue;
}
const std::shared_ptr<std::string> &CustomFields::getDefaultValue() const noexcept
{
    return _defaultValue;
}
void CustomFields::setDefaultValue(const std::string &pDefaultValue) noexcept
{
    _defaultValue = std::make_shared<std::string>(pDefaultValue);
    _dirtyFlag[14] = true;
}
void CustomFields::setDefaultValue(std::string &&pDefaultValue) noexcept
{
    _defaultValue = std::make_shared<std::string>(std::move(pDefaultValue));
    _dirtyFlag[14] = true;
}


const std::string &CustomFields::getValueOfName() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_name)
        return *_name;
    return defaultValue;
}
const std::shared_ptr<std::string> &CustomFields::getName() const noexcept
{
    return _name;
}
void CustomFields::setName(const std::string &pName) noexcept
{
    _name = std::make_shared<std::string>(pName);
    _dirtyFlag[15] = true;
}
void CustomFields::setName(std::string &&pName) noexcept
{
    _name = std::make_shared<std::string>(std::move(pName));
    _dirtyFlag[15] = true;
}


const ::trantor::Date &CustomFields::getValueOfCreatedAt() const noexcept
{
    const static ::trantor::Date defaultValue = ::trantor::Date();
    if(_createdAt)
        return *_createdAt;
    return defaultValue;
}
const std::shared_ptr<::trantor::Date> &CustomFields::getCreatedAt() const noexcept
{
    return _createdAt;
}
void CustomFields::setCreatedAt(const ::trantor::Date &pCreatedAt) noexcept
{
    _createdAt = std::make_shared<::trantor::Date>(pCreatedAt);
    _dirtyFlag[16] = true;
}


const ::trantor::Date &CustomFields::getValueOfUpdatedAt() const noexcept
{
    const static ::trantor::Date defaultValue = ::trantor::Date();
    if(_updatedAt)
        return *_updatedAt;
    return defaultValue;
}
const std::shared_ptr<::trantor::Date> &CustomFields::getUpdatedAt() const noexcept
{
    return _updatedAt;
}
void CustomFields::setUpdatedAt(const ::trantor::Date &pUpdatedAt) noexcept
{
    _updatedAt = std::make_shared<::trantor::Date>(pUpdatedAt);
    _dirtyFlag[17] = true;
}


void CustomFields::updateId(const uint64_t id)
{
}

const std::vector<std::string> &CustomFields::insertColumns() noexcept
{
    static const std::vector<std::string> _inCols={
        "type",
        "field_format",
        "regexp",
        "min_length",
        "max_length",
        "is_required",
        "is_for_all",
        "is_filter",
        "position",
        "searchable",
        "editable",
        "visible",
        "multi_value",
        "default_value",
        "name",
        "created_at",
        "updated_at"
    };
    return _inCols;
}

void CustomFields::outputArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(getType())
    {
        binder << getValueOfType();
    }
    else
    {
        binder << nullptr;
    }
    if(getFieldFormat())
    {
        binder << getValueOfFieldFormat();
    }
    else
    {
        binder << nullptr;
    }
    if(getRegexp())
    {
        binder << getValueOfRegexp();
    }
    else
    {
        binder << nullptr;
    }
    if(getMinLength())
    {
        binder << getValueOfMinLength();
    }
    else
    {
        binder << nullptr;
    }
    if(getMaxLength())
    {
        binder << getValueOfMaxLength();
    }
    else
    {
        binder << nullptr;
    }
    if(getIsRequired())
    {
        binder << getValueOfIsRequired();
    }
    else
    {
        binder << nullptr;
    }
    if(getIsForAll())
    {
        binder << getValueOfIsForAll();
    }
    else
    {
        binder << nullptr;
    }
    if(getIsFilter())
    {
        binder << getValueOfIsFilter();
    }
    else
    {
        binder << nullptr;
    }
    if(getPosition())
    {
        binder << getValueOfPosition();
    }
    else
    {
        binder << nullptr;
    }
    if(getSearchable())
    {
        binder << getValueOfSearchable();
    }
    else
    {
        binder << nullptr;
    }
    if(getEditable())
    {
        binder << getValueOfEditable();
    }
    else
    {
        binder << nullptr;
    }
    if(getVisible())
    {
        binder << getValueOfVisible();
    }
    else
    {
        binder << nullptr;
    }
    if(getMultiValue())
    {
        binder << getValueOfMultiValue();
    }
    else
    {
        binder << nullptr;
    }
    if(getDefaultValue())
    {
        binder << getValueOfDefaultValue();
    }
    else
    {
        binder << nullptr;
    }
    if(getName())
    {
        binder << getValueOfName();
    }
    else
    {
        binder << nullptr;
    }
    if(getCreatedAt())
    {
        binder << getValueOfCreatedAt();
    }
    else
    {
        binder << nullptr;
    }
    if(getUpdatedAt())
    {
        binder << getValueOfUpdatedAt();
    }
    else
    {
        binder << nullptr;
    }
}

const std::vector<std::string> CustomFields::updateColumns() const
{
    std::vector<std::string> ret;
    for(size_t i=0;i<sizeof(_dirtyFlag);i++)
    {
        if(_dirtyFlag[i])
        {
            ret.push_back(getColumnName(i));
        }
    }
    return ret;
}

void CustomFields::updateArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(_dirtyFlag[1])
    {
        if(getType())
        {
            binder << getValueOfType();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[2])
    {
        if(getFieldFormat())
        {
            binder << getValueOfFieldFormat();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[3])
    {
        if(getRegexp())
        {
            binder << getValueOfRegexp();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[4])
    {
        if(getMinLength())
        {
            binder << getValueOfMinLength();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[5])
    {
        if(getMaxLength())
        {
            binder << getValueOfMaxLength();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[6])
    {
        if(getIsRequired())
        {
            binder << getValueOfIsRequired();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[7])
    {
        if(getIsForAll())
        {
            binder << getValueOfIsForAll();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[8])
    {
        if(getIsFilter())
        {
            binder << getValueOfIsFilter();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[9])
    {
        if(getPosition())
        {
            binder << getValueOfPosition();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[10])
    {
        if(getSearchable())
        {
            binder << getValueOfSearchable();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[11])
    {
        if(getEditable())
        {
            binder << getValueOfEditable();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[12])
    {
        if(getVisible())
        {
            binder << getValueOfVisible();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[13])
    {
        if(getMultiValue())
        {
            binder << getValueOfMultiValue();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[14])
    {
        if(getDefaultValue())
        {
            binder << getValueOfDefaultValue();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[15])
    {
        if(getName())
        {
            binder << getValueOfName();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[16])
    {
        if(getCreatedAt())
        {
            binder << getValueOfCreatedAt();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[17])
    {
        if(getUpdatedAt())
        {
            binder << getValueOfUpdatedAt();
        }
        else
        {
            binder << nullptr;
        }
    }
}
Json::Value CustomFields::toJson() const
{
    Json::Value ret;
    if(getId())
    {
        ret["id"]=getValueOfId();
    }
    else
    {
        ret["id"]=Json::Value();
    }
    if(getType())
    {
        ret["type"]=getValueOfType();
    }
    else
    {
        ret["type"]=Json::Value();
    }
    if(getFieldFormat())
    {
        ret["field_format"]=getValueOfFieldFormat();
    }
    else
    {
        ret["field_format"]=Json::Value();
    }
    if(getRegexp())
    {
        ret["regexp"]=getValueOfRegexp();
    }
    else
    {
        ret["regexp"]=Json::Value();
    }
    if(getMinLength())
    {
        ret["min_length"]=getValueOfMinLength();
    }
    else
    {
        ret["min_length"]=Json::Value();
    }
    if(getMaxLength())
    {
        ret["max_length"]=getValueOfMaxLength();
    }
    else
    {
        ret["max_length"]=Json::Value();
    }
    if(getIsRequired())
    {
        ret["is_required"]=getValueOfIsRequired();
    }
    else
    {
        ret["is_required"]=Json::Value();
    }
    if(getIsForAll())
    {
        ret["is_for_all"]=getValueOfIsForAll();
    }
    else
    {
        ret["is_for_all"]=Json::Value();
    }
    if(getIsFilter())
    {
        ret["is_filter"]=getValueOfIsFilter();
    }
    else
    {
        ret["is_filter"]=Json::Value();
    }
    if(getPosition())
    {
        ret["position"]=getValueOfPosition();
    }
    else
    {
        ret["position"]=Json::Value();
    }
    if(getSearchable())
    {
        ret["searchable"]=getValueOfSearchable();
    }
    else
    {
        ret["searchable"]=Json::Value();
    }
    if(getEditable())
    {
        ret["editable"]=getValueOfEditable();
    }
    else
    {
        ret["editable"]=Json::Value();
    }
    if(getVisible())
    {
        ret["visible"]=getValueOfVisible();
    }
    else
    {
        ret["visible"]=Json::Value();
    }
    if(getMultiValue())
    {
        ret["multi_value"]=getValueOfMultiValue();
    }
    else
    {
        ret["multi_value"]=Json::Value();
    }
    if(getDefaultValue())
    {
        ret["default_value"]=getValueOfDefaultValue();
    }
    else
    {
        ret["default_value"]=Json::Value();
    }
    if(getName())
    {
        ret["name"]=getValueOfName();
    }
    else
    {
        ret["name"]=Json::Value();
    }
    if(getCreatedAt())
    {
        ret["created_at"]=getCreatedAt()->toDbStringLocal();
    }
    else
    {
        ret["created_at"]=Json::Value();
    }
    if(getUpdatedAt())
    {
        ret["updated_at"]=getUpdatedAt()->toDbStringLocal();
    }
    else
    {
        ret["updated_at"]=Json::Value();
    }
    return ret;
}
