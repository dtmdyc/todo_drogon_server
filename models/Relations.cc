/**
 *
 *  Relations.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */

#include "Relations.h"
#include <drogon/utils/Utilities.h>
#include <string>

using namespace drogon;
using namespace drogon_model::openproject4;

const std::string Relations::Cols::_id = "id";
const std::string Relations::Cols::_from_id = "from_id";
const std::string Relations::Cols::_to_id = "to_id";
const std::string Relations::Cols::_delay = "delay";
const std::string Relations::Cols::_description = "description";
const std::string Relations::Cols::_hierarchy = "hierarchy";
const std::string Relations::Cols::_relates = "relates";
const std::string Relations::Cols::_duplicates = "duplicates";
const std::string Relations::Cols::_blocks = "blocks";
const std::string Relations::Cols::_follows = "follows";
const std::string Relations::Cols::_includes = "includes";
const std::string Relations::Cols::_requires = "requires";
const std::string Relations::Cols::_count = "count";
const std::string Relations::primaryKeyName = "id";
const bool Relations::hasPrimaryKey = true;
const std::string Relations::tableName = "relations";

const std::vector<typename Relations::MetaData> Relations::_metaData={
{"id","int32_t","integer",4,1,1,1},
{"from_id","int32_t","integer",4,0,0,1},
{"to_id","int32_t","integer",4,0,0,1},
{"delay","int32_t","integer",4,0,0,0},
{"description","std::string","text",0,0,0,0},
{"hierarchy","int32_t","integer",4,0,0,1},
{"relates","int32_t","integer",4,0,0,1},
{"duplicates","int32_t","integer",4,0,0,1},
{"blocks","int32_t","integer",4,0,0,1},
{"follows","int32_t","integer",4,0,0,1},
{"includes","int32_t","integer",4,0,0,1},
{"requires","int32_t","integer",4,0,0,1},
{"count","int32_t","integer",4,0,0,1}
};
const std::string &Relations::getColumnName(size_t index) noexcept(false)
{
    assert(index < _metaData.size());
    return _metaData[index]._colName;
}
Relations::Relations(const Row &r) noexcept
{
        if(!r["id"].isNull())
        {
            _id=std::make_shared<int32_t>(r["id"].as<int32_t>());
        }
        if(!r["from_id"].isNull())
        {
            _fromId=std::make_shared<int32_t>(r["from_id"].as<int32_t>());
        }
        if(!r["to_id"].isNull())
        {
            _toId=std::make_shared<int32_t>(r["to_id"].as<int32_t>());
        }
        if(!r["delay"].isNull())
        {
            _delay=std::make_shared<int32_t>(r["delay"].as<int32_t>());
        }
        if(!r["description"].isNull())
        {
            _description=std::make_shared<std::string>(r["description"].as<std::string>());
        }
        if(!r["hierarchy"].isNull())
        {
            _hierarchy=std::make_shared<int32_t>(r["hierarchy"].as<int32_t>());
        }
        if(!r["relates"].isNull())
        {
            _relates=std::make_shared<int32_t>(r["relates"].as<int32_t>());
        }
        if(!r["duplicates"].isNull())
        {
            _duplicates=std::make_shared<int32_t>(r["duplicates"].as<int32_t>());
        }
        if(!r["blocks"].isNull())
        {
            _blocks=std::make_shared<int32_t>(r["blocks"].as<int32_t>());
        }
        if(!r["follows"].isNull())
        {
            _follows=std::make_shared<int32_t>(r["follows"].as<int32_t>());
        }
        if(!r["includes"].isNull())
        {
            _includes=std::make_shared<int32_t>(r["includes"].as<int32_t>());
        }
        if(!r["requires"].isNull())
        {
            _requires=std::make_shared<int32_t>(r["requires"].as<int32_t>());
        }
        if(!r["count"].isNull())
        {
            _count=std::make_shared<int32_t>(r["count"].as<int32_t>());
        }
}
const int32_t &Relations::getValueOfId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_id)
        return *_id;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getId() const noexcept
{
    return _id;
}
const typename Relations::PrimaryKeyType & Relations::getPrimaryKey() const
{
    assert(_id);
    return *_id;
}

const int32_t &Relations::getValueOfFromId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_fromId)
        return *_fromId;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getFromId() const noexcept
{
    return _fromId;
}
void Relations::setFromId(const int32_t &pFromId) noexcept
{
    _fromId = std::make_shared<int32_t>(pFromId);
    _dirtyFlag[1] = true;
}


const int32_t &Relations::getValueOfToId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_toId)
        return *_toId;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getToId() const noexcept
{
    return _toId;
}
void Relations::setToId(const int32_t &pToId) noexcept
{
    _toId = std::make_shared<int32_t>(pToId);
    _dirtyFlag[2] = true;
}


const int32_t &Relations::getValueOfDelay() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_delay)
        return *_delay;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getDelay() const noexcept
{
    return _delay;
}
void Relations::setDelay(const int32_t &pDelay) noexcept
{
    _delay = std::make_shared<int32_t>(pDelay);
    _dirtyFlag[3] = true;
}


const std::string &Relations::getValueOfDescription() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_description)
        return *_description;
    return defaultValue;
}
const std::shared_ptr<std::string> &Relations::getDescription() const noexcept
{
    return _description;
}
void Relations::setDescription(const std::string &pDescription) noexcept
{
    _description = std::make_shared<std::string>(pDescription);
    _dirtyFlag[4] = true;
}
void Relations::setDescription(std::string &&pDescription) noexcept
{
    _description = std::make_shared<std::string>(std::move(pDescription));
    _dirtyFlag[4] = true;
}


const int32_t &Relations::getValueOfHierarchy() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_hierarchy)
        return *_hierarchy;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getHierarchy() const noexcept
{
    return _hierarchy;
}
void Relations::setHierarchy(const int32_t &pHierarchy) noexcept
{
    _hierarchy = std::make_shared<int32_t>(pHierarchy);
    _dirtyFlag[5] = true;
}


const int32_t &Relations::getValueOfRelates() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_relates)
        return *_relates;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getRelates() const noexcept
{
    return _relates;
}
void Relations::setRelates(const int32_t &pRelates) noexcept
{
    _relates = std::make_shared<int32_t>(pRelates);
    _dirtyFlag[6] = true;
}


const int32_t &Relations::getValueOfDuplicates() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_duplicates)
        return *_duplicates;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getDuplicates() const noexcept
{
    return _duplicates;
}
void Relations::setDuplicates(const int32_t &pDuplicates) noexcept
{
    _duplicates = std::make_shared<int32_t>(pDuplicates);
    _dirtyFlag[7] = true;
}


const int32_t &Relations::getValueOfBlocks() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_blocks)
        return *_blocks;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getBlocks() const noexcept
{
    return _blocks;
}
void Relations::setBlocks(const int32_t &pBlocks) noexcept
{
    _blocks = std::make_shared<int32_t>(pBlocks);
    _dirtyFlag[8] = true;
}


const int32_t &Relations::getValueOfFollows() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_follows)
        return *_follows;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getFollows() const noexcept
{
    return _follows;
}
void Relations::setFollows(const int32_t &pFollows) noexcept
{
    _follows = std::make_shared<int32_t>(pFollows);
    _dirtyFlag[9] = true;
}


const int32_t &Relations::getValueOfIncludes() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_includes)
        return *_includes;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getIncludes() const noexcept
{
    return _includes;
}
void Relations::setIncludes(const int32_t &pIncludes) noexcept
{
    _includes = std::make_shared<int32_t>(pIncludes);
    _dirtyFlag[10] = true;
}


const int32_t &Relations::getValueOfRequires() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_requires)
        return *_requires;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getRequires() const noexcept
{
    return _requires;
}
void Relations::setRequires(const int32_t &pRequires) noexcept
{
    _requires = std::make_shared<int32_t>(pRequires);
    _dirtyFlag[11] = true;
}


const int32_t &Relations::getValueOfCount() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_count)
        return *_count;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getCount() const noexcept
{
    return _count;
}
void Relations::setCount(const int32_t &pCount) noexcept
{
    _count = std::make_shared<int32_t>(pCount);
    _dirtyFlag[12] = true;
}


void Relations::updateId(const uint64_t id)
{
}

const std::vector<std::string> &Relations::insertColumns() noexcept
{
    static const std::vector<std::string> _inCols={
        "from_id",
        "to_id",
        "delay",
        "description",
        "hierarchy",
        "relates",
        "duplicates",
        "blocks",
        "follows",
        "includes",
        "requires",
        "count"
    };
    return _inCols;
}

void Relations::outputArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(getFromId())
    {
        binder << getValueOfFromId();
    }
    else
    {
        binder << nullptr;
    }
    if(getToId())
    {
        binder << getValueOfToId();
    }
    else
    {
        binder << nullptr;
    }
    if(getDelay())
    {
        binder << getValueOfDelay();
    }
    else
    {
        binder << nullptr;
    }
    if(getDescription())
    {
        binder << getValueOfDescription();
    }
    else
    {
        binder << nullptr;
    }
    if(getHierarchy())
    {
        binder << getValueOfHierarchy();
    }
    else
    {
        binder << nullptr;
    }
    if(getRelates())
    {
        binder << getValueOfRelates();
    }
    else
    {
        binder << nullptr;
    }
    if(getDuplicates())
    {
        binder << getValueOfDuplicates();
    }
    else
    {
        binder << nullptr;
    }
    if(getBlocks())
    {
        binder << getValueOfBlocks();
    }
    else
    {
        binder << nullptr;
    }
    if(getFollows())
    {
        binder << getValueOfFollows();
    }
    else
    {
        binder << nullptr;
    }
    if(getIncludes())
    {
        binder << getValueOfIncludes();
    }
    else
    {
        binder << nullptr;
    }
    if(getRequires())
    {
        binder << getValueOfRequires();
    }
    else
    {
        binder << nullptr;
    }
    if(getCount())
    {
        binder << getValueOfCount();
    }
    else
    {
        binder << nullptr;
    }
}

const std::vector<std::string> Relations::updateColumns() const
{
    std::vector<std::string> ret;
    for(size_t i=0;i<sizeof(_dirtyFlag);i++)
    {
        if(_dirtyFlag[i])
        {
            ret.push_back(getColumnName(i));
        }
    }
    return ret;
}

void Relations::updateArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(_dirtyFlag[1])
    {
        if(getFromId())
        {
            binder << getValueOfFromId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[2])
    {
        if(getToId())
        {
            binder << getValueOfToId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[3])
    {
        if(getDelay())
        {
            binder << getValueOfDelay();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[4])
    {
        if(getDescription())
        {
            binder << getValueOfDescription();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[5])
    {
        if(getHierarchy())
        {
            binder << getValueOfHierarchy();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[6])
    {
        if(getRelates())
        {
            binder << getValueOfRelates();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[7])
    {
        if(getDuplicates())
        {
            binder << getValueOfDuplicates();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[8])
    {
        if(getBlocks())
        {
            binder << getValueOfBlocks();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[9])
    {
        if(getFollows())
        {
            binder << getValueOfFollows();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[10])
    {
        if(getIncludes())
        {
            binder << getValueOfIncludes();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[11])
    {
        if(getRequires())
        {
            binder << getValueOfRequires();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[12])
    {
        if(getCount())
        {
            binder << getValueOfCount();
        }
        else
        {
            binder << nullptr;
        }
    }
}
Json::Value Relations::toJson() const
{
    Json::Value ret;
    if(getId())
    {
        ret["id"]=getValueOfId();
    }
    else
    {
        ret["id"]=Json::Value();
    }
    if(getFromId())
    {
        ret["from_id"]=getValueOfFromId();
    }
    else
    {
        ret["from_id"]=Json::Value();
    }
    if(getToId())
    {
        ret["to_id"]=getValueOfToId();
    }
    else
    {
        ret["to_id"]=Json::Value();
    }
    if(getDelay())
    {
        ret["delay"]=getValueOfDelay();
    }
    else
    {
        ret["delay"]=Json::Value();
    }
    if(getDescription())
    {
        ret["description"]=getValueOfDescription();
    }
    else
    {
        ret["description"]=Json::Value();
    }
    if(getHierarchy())
    {
        ret["hierarchy"]=getValueOfHierarchy();
    }
    else
    {
        ret["hierarchy"]=Json::Value();
    }
    if(getRelates())
    {
        ret["relates"]=getValueOfRelates();
    }
    else
    {
        ret["relates"]=Json::Value();
    }
    if(getDuplicates())
    {
        ret["duplicates"]=getValueOfDuplicates();
    }
    else
    {
        ret["duplicates"]=Json::Value();
    }
    if(getBlocks())
    {
        ret["blocks"]=getValueOfBlocks();
    }
    else
    {
        ret["blocks"]=Json::Value();
    }
    if(getFollows())
    {
        ret["follows"]=getValueOfFollows();
    }
    else
    {
        ret["follows"]=Json::Value();
    }
    if(getIncludes())
    {
        ret["includes"]=getValueOfIncludes();
    }
    else
    {
        ret["includes"]=Json::Value();
    }
    if(getRequires())
    {
        ret["requires"]=getValueOfRequires();
    }
    else
    {
        ret["requires"]=Json::Value();
    }
    if(getCount())
    {
        ret["count"]=getValueOfCount();
    }
    else
    {
        ret["count"]=Json::Value();
    }
    return ret;
}
