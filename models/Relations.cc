/**
 *
 *  Relations.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */

#include "Relations.h"
#include <drogon/utils/Utilities.h>
#include <string>

using namespace drogon;
using namespace drogon_model::openproject6;

const std::string Relations::Cols::_id = "id";
const std::string Relations::Cols::_from_id = "from_id";
const std::string Relations::Cols::_to_id = "to_id";
const std::string Relations::Cols::_delay = "delay";
const std::string Relations::Cols::_description = "description";
const std::string Relations::Cols::_hierarchy = "hierarchy";
const std::string Relations::Cols::_relates = "relates";
const std::string Relations::Cols::_duplicates = "duplicates";
const std::string Relations::Cols::_blocks = "blocks";
const std::string Relations::Cols::_follows = "follows";
const std::string Relations::Cols::_includes = "includes";
const std::string Relations::Cols::_requires = "requires";
const std::string Relations::Cols::_count = "count";
const std::string Relations::primaryKeyName = "id";
const bool Relations::hasPrimaryKey = true;
const std::string Relations::tableName = "relations";

const std::vector<typename Relations::MetaData> Relations::_metaData={
{"id","int32_t","integer",4,1,1,1},
{"from_id","int32_t","integer",4,0,0,1},
{"to_id","int32_t","integer",4,0,0,1},
{"delay","int32_t","integer",4,0,0,0},
{"description","std::string","text",0,0,0,0},
{"hierarchy","int32_t","integer",4,0,0,1},
{"relates","int32_t","integer",4,0,0,1},
{"duplicates","int32_t","integer",4,0,0,1},
{"blocks","int32_t","integer",4,0,0,1},
{"follows","int32_t","integer",4,0,0,1},
{"includes","int32_t","integer",4,0,0,1},
{"requires","int32_t","integer",4,0,0,1},
{"count","int32_t","integer",4,0,0,1}
};
const std::string &Relations::getColumnName(size_t index) noexcept(false)
{
    assert(index < _metaData.size());
    return _metaData[index]._colName;
}
Relations::Relations(const Row &r, const ssize_t indexOffset) noexcept
{
    if(indexOffset < 0)
    {
        if(!r["id"].isNull())
        {
            _id=std::make_shared<int32_t>(r["id"].as<int32_t>());
        }
        if(!r["from_id"].isNull())
        {
            _fromId=std::make_shared<int32_t>(r["from_id"].as<int32_t>());
        }
        if(!r["to_id"].isNull())
        {
            _toId=std::make_shared<int32_t>(r["to_id"].as<int32_t>());
        }
        if(!r["delay"].isNull())
        {
            _delay=std::make_shared<int32_t>(r["delay"].as<int32_t>());
        }
        if(!r["description"].isNull())
        {
            _description=std::make_shared<std::string>(r["description"].as<std::string>());
        }
        if(!r["hierarchy"].isNull())
        {
            _hierarchy=std::make_shared<int32_t>(r["hierarchy"].as<int32_t>());
        }
        if(!r["relates"].isNull())
        {
            _relates=std::make_shared<int32_t>(r["relates"].as<int32_t>());
        }
        if(!r["duplicates"].isNull())
        {
            _duplicates=std::make_shared<int32_t>(r["duplicates"].as<int32_t>());
        }
        if(!r["blocks"].isNull())
        {
            _blocks=std::make_shared<int32_t>(r["blocks"].as<int32_t>());
        }
        if(!r["follows"].isNull())
        {
            _follows=std::make_shared<int32_t>(r["follows"].as<int32_t>());
        }
        if(!r["includes"].isNull())
        {
            _includes=std::make_shared<int32_t>(r["includes"].as<int32_t>());
        }
        if(!r["requires"].isNull())
        {
            _requires=std::make_shared<int32_t>(r["requires"].as<int32_t>());
        }
        if(!r["count"].isNull())
        {
            _count=std::make_shared<int32_t>(r["count"].as<int32_t>());
        }
    }
    else
    {
        size_t offset = (size_t)indexOffset;
        if(offset + 13 > r.size())
        {
            LOG_FATAL << "Invalid SQL result for this model";
            return;
        }
        size_t index;
        index = offset + 0;
        if(!r[index].isNull())
        {
            _id=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 1;
        if(!r[index].isNull())
        {
            _fromId=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 2;
        if(!r[index].isNull())
        {
            _toId=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 3;
        if(!r[index].isNull())
        {
            _delay=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 4;
        if(!r[index].isNull())
        {
            _description=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 5;
        if(!r[index].isNull())
        {
            _hierarchy=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 6;
        if(!r[index].isNull())
        {
            _relates=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 7;
        if(!r[index].isNull())
        {
            _duplicates=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 8;
        if(!r[index].isNull())
        {
            _blocks=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 9;
        if(!r[index].isNull())
        {
            _follows=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 10;
        if(!r[index].isNull())
        {
            _includes=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 11;
        if(!r[index].isNull())
        {
            _requires=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 12;
        if(!r[index].isNull())
        {
            _count=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
    }

}

Relations::Relations(const Json::Value &pJson, const std::vector<std::string> &pMasqueradingVector) noexcept(false)
{
    if(pMasqueradingVector.size() != 13)
    {
        LOG_ERROR << "Bad masquerading vector";
        return;
    }
    if(!pMasqueradingVector[0].empty() && pJson.isMember(pMasqueradingVector[0]))
    {
        _id=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[0]].asInt64());
    }
    if(!pMasqueradingVector[1].empty() && pJson.isMember(pMasqueradingVector[1]))
    {
        _fromId=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[1]].asInt64());
    }
    if(!pMasqueradingVector[2].empty() && pJson.isMember(pMasqueradingVector[2]))
    {
        _toId=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[2]].asInt64());
    }
    if(!pMasqueradingVector[3].empty() && pJson.isMember(pMasqueradingVector[3]))
    {
        _delay=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[3]].asInt64());
    }
    if(!pMasqueradingVector[4].empty() && pJson.isMember(pMasqueradingVector[4]))
    {
        _description=std::make_shared<std::string>(pJson[pMasqueradingVector[4]].asString());
    }
    if(!pMasqueradingVector[5].empty() && pJson.isMember(pMasqueradingVector[5]))
    {
        _hierarchy=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[5]].asInt64());
    }
    if(!pMasqueradingVector[6].empty() && pJson.isMember(pMasqueradingVector[6]))
    {
        _relates=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[6]].asInt64());
    }
    if(!pMasqueradingVector[7].empty() && pJson.isMember(pMasqueradingVector[7]))
    {
        _duplicates=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[7]].asInt64());
    }
    if(!pMasqueradingVector[8].empty() && pJson.isMember(pMasqueradingVector[8]))
    {
        _blocks=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[8]].asInt64());
    }
    if(!pMasqueradingVector[9].empty() && pJson.isMember(pMasqueradingVector[9]))
    {
        _follows=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[9]].asInt64());
    }
    if(!pMasqueradingVector[10].empty() && pJson.isMember(pMasqueradingVector[10]))
    {
        _includes=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[10]].asInt64());
    }
    if(!pMasqueradingVector[11].empty() && pJson.isMember(pMasqueradingVector[11]))
    {
        _requires=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[11]].asInt64());
    }
    if(!pMasqueradingVector[12].empty() && pJson.isMember(pMasqueradingVector[12]))
    {
        _count=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[12]].asInt64());
    }
}

Relations::Relations(const Json::Value &pJson) noexcept(false)
{
    if(pJson.isMember("id"))
    {
        _id=std::make_shared<int32_t>((int32_t)pJson["id"].asInt64());
    }
    if(pJson.isMember("from_id"))
    {
        _fromId=std::make_shared<int32_t>((int32_t)pJson["from_id"].asInt64());
    }
    if(pJson.isMember("to_id"))
    {
        _toId=std::make_shared<int32_t>((int32_t)pJson["to_id"].asInt64());
    }
    if(pJson.isMember("delay"))
    {
        _delay=std::make_shared<int32_t>((int32_t)pJson["delay"].asInt64());
    }
    if(pJson.isMember("description"))
    {
        _description=std::make_shared<std::string>(pJson["description"].asString());
    }
    if(pJson.isMember("hierarchy"))
    {
        _hierarchy=std::make_shared<int32_t>((int32_t)pJson["hierarchy"].asInt64());
    }
    if(pJson.isMember("relates"))
    {
        _relates=std::make_shared<int32_t>((int32_t)pJson["relates"].asInt64());
    }
    if(pJson.isMember("duplicates"))
    {
        _duplicates=std::make_shared<int32_t>((int32_t)pJson["duplicates"].asInt64());
    }
    if(pJson.isMember("blocks"))
    {
        _blocks=std::make_shared<int32_t>((int32_t)pJson["blocks"].asInt64());
    }
    if(pJson.isMember("follows"))
    {
        _follows=std::make_shared<int32_t>((int32_t)pJson["follows"].asInt64());
    }
    if(pJson.isMember("includes"))
    {
        _includes=std::make_shared<int32_t>((int32_t)pJson["includes"].asInt64());
    }
    if(pJson.isMember("requires"))
    {
        _requires=std::make_shared<int32_t>((int32_t)pJson["requires"].asInt64());
    }
    if(pJson.isMember("count"))
    {
        _count=std::make_shared<int32_t>((int32_t)pJson["count"].asInt64());
    }
}

void Relations::updateByMasqueradedJson(const Json::Value &pJson,
                                            const std::vector<std::string> &pMasqueradingVector) noexcept(false)
{
    if(pMasqueradingVector.size() != 13)
    {
        LOG_ERROR << "Bad masquerading vector";
        return;
    }
    if(!pMasqueradingVector[0].empty() && pJson.isMember(pMasqueradingVector[0]))
    {
        _id=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[0]].asInt64());
    }
    if(!pMasqueradingVector[1].empty() && pJson.isMember(pMasqueradingVector[1]))
    {
        _dirtyFlag[1] = true;
        _fromId=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[1]].asInt64());
    }
    if(!pMasqueradingVector[2].empty() && pJson.isMember(pMasqueradingVector[2]))
    {
        _dirtyFlag[2] = true;
        _toId=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[2]].asInt64());
    }
    if(!pMasqueradingVector[3].empty() && pJson.isMember(pMasqueradingVector[3]))
    {
        _dirtyFlag[3] = true;
        _delay=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[3]].asInt64());
    }
    if(!pMasqueradingVector[4].empty() && pJson.isMember(pMasqueradingVector[4]))
    {
        _dirtyFlag[4] = true;
        _description=std::make_shared<std::string>(pJson[pMasqueradingVector[4]].asString());
    }
    if(!pMasqueradingVector[5].empty() && pJson.isMember(pMasqueradingVector[5]))
    {
        _dirtyFlag[5] = true;
        _hierarchy=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[5]].asInt64());
    }
    if(!pMasqueradingVector[6].empty() && pJson.isMember(pMasqueradingVector[6]))
    {
        _dirtyFlag[6] = true;
        _relates=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[6]].asInt64());
    }
    if(!pMasqueradingVector[7].empty() && pJson.isMember(pMasqueradingVector[7]))
    {
        _dirtyFlag[7] = true;
        _duplicates=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[7]].asInt64());
    }
    if(!pMasqueradingVector[8].empty() && pJson.isMember(pMasqueradingVector[8]))
    {
        _dirtyFlag[8] = true;
        _blocks=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[8]].asInt64());
    }
    if(!pMasqueradingVector[9].empty() && pJson.isMember(pMasqueradingVector[9]))
    {
        _dirtyFlag[9] = true;
        _follows=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[9]].asInt64());
    }
    if(!pMasqueradingVector[10].empty() && pJson.isMember(pMasqueradingVector[10]))
    {
        _dirtyFlag[10] = true;
        _includes=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[10]].asInt64());
    }
    if(!pMasqueradingVector[11].empty() && pJson.isMember(pMasqueradingVector[11]))
    {
        _dirtyFlag[11] = true;
        _requires=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[11]].asInt64());
    }
    if(!pMasqueradingVector[12].empty() && pJson.isMember(pMasqueradingVector[12]))
    {
        _dirtyFlag[12] = true;
        _count=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[12]].asInt64());
    }
}
                                                                    
void Relations::updateByJson(const Json::Value &pJson) noexcept(false)
{
    if(pJson.isMember("id"))
    {
        _id=std::make_shared<int32_t>((int32_t)pJson["id"].asInt64());
    }
    if(pJson.isMember("from_id"))
    {
        _dirtyFlag[1] = true;
        _fromId=std::make_shared<int32_t>((int32_t)pJson["from_id"].asInt64());
    }
    if(pJson.isMember("to_id"))
    {
        _dirtyFlag[2] = true;
        _toId=std::make_shared<int32_t>((int32_t)pJson["to_id"].asInt64());
    }
    if(pJson.isMember("delay"))
    {
        _dirtyFlag[3] = true;
        _delay=std::make_shared<int32_t>((int32_t)pJson["delay"].asInt64());
    }
    if(pJson.isMember("description"))
    {
        _dirtyFlag[4] = true;
        _description=std::make_shared<std::string>(pJson["description"].asString());
    }
    if(pJson.isMember("hierarchy"))
    {
        _dirtyFlag[5] = true;
        _hierarchy=std::make_shared<int32_t>((int32_t)pJson["hierarchy"].asInt64());
    }
    if(pJson.isMember("relates"))
    {
        _dirtyFlag[6] = true;
        _relates=std::make_shared<int32_t>((int32_t)pJson["relates"].asInt64());
    }
    if(pJson.isMember("duplicates"))
    {
        _dirtyFlag[7] = true;
        _duplicates=std::make_shared<int32_t>((int32_t)pJson["duplicates"].asInt64());
    }
    if(pJson.isMember("blocks"))
    {
        _dirtyFlag[8] = true;
        _blocks=std::make_shared<int32_t>((int32_t)pJson["blocks"].asInt64());
    }
    if(pJson.isMember("follows"))
    {
        _dirtyFlag[9] = true;
        _follows=std::make_shared<int32_t>((int32_t)pJson["follows"].asInt64());
    }
    if(pJson.isMember("includes"))
    {
        _dirtyFlag[10] = true;
        _includes=std::make_shared<int32_t>((int32_t)pJson["includes"].asInt64());
    }
    if(pJson.isMember("requires"))
    {
        _dirtyFlag[11] = true;
        _requires=std::make_shared<int32_t>((int32_t)pJson["requires"].asInt64());
    }
    if(pJson.isMember("count"))
    {
        _dirtyFlag[12] = true;
        _count=std::make_shared<int32_t>((int32_t)pJson["count"].asInt64());
    }
}

const int32_t &Relations::getValueOfId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_id)
        return *_id;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getId() const noexcept
{
    return _id;
}
const typename Relations::PrimaryKeyType & Relations::getPrimaryKey() const
{
    assert(_id);
    return *_id;
}

const int32_t &Relations::getValueOfFromId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_fromId)
        return *_fromId;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getFromId() const noexcept
{
    return _fromId;
}
void Relations::setFromId(const int32_t &pFromId) noexcept
{
    _fromId = std::make_shared<int32_t>(pFromId);
    _dirtyFlag[1] = true;
}


const int32_t &Relations::getValueOfToId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_toId)
        return *_toId;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getToId() const noexcept
{
    return _toId;
}
void Relations::setToId(const int32_t &pToId) noexcept
{
    _toId = std::make_shared<int32_t>(pToId);
    _dirtyFlag[2] = true;
}


const int32_t &Relations::getValueOfDelay() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_delay)
        return *_delay;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getDelay() const noexcept
{
    return _delay;
}
void Relations::setDelay(const int32_t &pDelay) noexcept
{
    _delay = std::make_shared<int32_t>(pDelay);
    _dirtyFlag[3] = true;
}


const std::string &Relations::getValueOfDescription() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_description)
        return *_description;
    return defaultValue;
}
const std::shared_ptr<std::string> &Relations::getDescription() const noexcept
{
    return _description;
}
void Relations::setDescription(const std::string &pDescription) noexcept
{
    _description = std::make_shared<std::string>(pDescription);
    _dirtyFlag[4] = true;
}
void Relations::setDescription(std::string &&pDescription) noexcept
{
    _description = std::make_shared<std::string>(std::move(pDescription));
    _dirtyFlag[4] = true;
}


const int32_t &Relations::getValueOfHierarchy() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_hierarchy)
        return *_hierarchy;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getHierarchy() const noexcept
{
    return _hierarchy;
}
void Relations::setHierarchy(const int32_t &pHierarchy) noexcept
{
    _hierarchy = std::make_shared<int32_t>(pHierarchy);
    _dirtyFlag[5] = true;
}


const int32_t &Relations::getValueOfRelates() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_relates)
        return *_relates;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getRelates() const noexcept
{
    return _relates;
}
void Relations::setRelates(const int32_t &pRelates) noexcept
{
    _relates = std::make_shared<int32_t>(pRelates);
    _dirtyFlag[6] = true;
}


const int32_t &Relations::getValueOfDuplicates() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_duplicates)
        return *_duplicates;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getDuplicates() const noexcept
{
    return _duplicates;
}
void Relations::setDuplicates(const int32_t &pDuplicates) noexcept
{
    _duplicates = std::make_shared<int32_t>(pDuplicates);
    _dirtyFlag[7] = true;
}


const int32_t &Relations::getValueOfBlocks() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_blocks)
        return *_blocks;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getBlocks() const noexcept
{
    return _blocks;
}
void Relations::setBlocks(const int32_t &pBlocks) noexcept
{
    _blocks = std::make_shared<int32_t>(pBlocks);
    _dirtyFlag[8] = true;
}


const int32_t &Relations::getValueOfFollows() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_follows)
        return *_follows;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getFollows() const noexcept
{
    return _follows;
}
void Relations::setFollows(const int32_t &pFollows) noexcept
{
    _follows = std::make_shared<int32_t>(pFollows);
    _dirtyFlag[9] = true;
}


const int32_t &Relations::getValueOfIncludes() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_includes)
        return *_includes;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getIncludes() const noexcept
{
    return _includes;
}
void Relations::setIncludes(const int32_t &pIncludes) noexcept
{
    _includes = std::make_shared<int32_t>(pIncludes);
    _dirtyFlag[10] = true;
}


const int32_t &Relations::getValueOfRequires() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_requires)
        return *_requires;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getRequires() const noexcept
{
    return _requires;
}
void Relations::setRequires(const int32_t &pRequires) noexcept
{
    _requires = std::make_shared<int32_t>(pRequires);
    _dirtyFlag[11] = true;
}


const int32_t &Relations::getValueOfCount() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_count)
        return *_count;
    return defaultValue;
}
const std::shared_ptr<int32_t> &Relations::getCount() const noexcept
{
    return _count;
}
void Relations::setCount(const int32_t &pCount) noexcept
{
    _count = std::make_shared<int32_t>(pCount);
    _dirtyFlag[12] = true;
}


void Relations::updateId(const uint64_t id)
{
}

const std::vector<std::string> &Relations::insertColumns() noexcept
{
    static const std::vector<std::string> _inCols={
        "from_id",
        "to_id",
        "delay",
        "description",
        "hierarchy",
        "relates",
        "duplicates",
        "blocks",
        "follows",
        "includes",
        "requires",
        "count"
    };
    return _inCols;
}

void Relations::outputArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(getFromId())
    {
        binder << getValueOfFromId();
    }
    else
    {
        binder << nullptr;
    }
    if(getToId())
    {
        binder << getValueOfToId();
    }
    else
    {
        binder << nullptr;
    }
    if(getDelay())
    {
        binder << getValueOfDelay();
    }
    else
    {
        binder << nullptr;
    }
    if(getDescription())
    {
        binder << getValueOfDescription();
    }
    else
    {
        binder << nullptr;
    }
    if(getHierarchy())
    {
        binder << getValueOfHierarchy();
    }
    else
    {
        binder << nullptr;
    }
    if(getRelates())
    {
        binder << getValueOfRelates();
    }
    else
    {
        binder << nullptr;
    }
    if(getDuplicates())
    {
        binder << getValueOfDuplicates();
    }
    else
    {
        binder << nullptr;
    }
    if(getBlocks())
    {
        binder << getValueOfBlocks();
    }
    else
    {
        binder << nullptr;
    }
    if(getFollows())
    {
        binder << getValueOfFollows();
    }
    else
    {
        binder << nullptr;
    }
    if(getIncludes())
    {
        binder << getValueOfIncludes();
    }
    else
    {
        binder << nullptr;
    }
    if(getRequires())
    {
        binder << getValueOfRequires();
    }
    else
    {
        binder << nullptr;
    }
    if(getCount())
    {
        binder << getValueOfCount();
    }
    else
    {
        binder << nullptr;
    }
}

const std::vector<std::string> Relations::updateColumns() const
{
    std::vector<std::string> ret;
    for(size_t i=0;i<sizeof(_dirtyFlag);i++)
    {
        if(_dirtyFlag[i])
        {
            ret.push_back(getColumnName(i));
        }
    }
    return ret;
}

void Relations::updateArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(_dirtyFlag[1])
    {
        if(getFromId())
        {
            binder << getValueOfFromId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[2])
    {
        if(getToId())
        {
            binder << getValueOfToId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[3])
    {
        if(getDelay())
        {
            binder << getValueOfDelay();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[4])
    {
        if(getDescription())
        {
            binder << getValueOfDescription();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[5])
    {
        if(getHierarchy())
        {
            binder << getValueOfHierarchy();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[6])
    {
        if(getRelates())
        {
            binder << getValueOfRelates();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[7])
    {
        if(getDuplicates())
        {
            binder << getValueOfDuplicates();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[8])
    {
        if(getBlocks())
        {
            binder << getValueOfBlocks();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[9])
    {
        if(getFollows())
        {
            binder << getValueOfFollows();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[10])
    {
        if(getIncludes())
        {
            binder << getValueOfIncludes();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[11])
    {
        if(getRequires())
        {
            binder << getValueOfRequires();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[12])
    {
        if(getCount())
        {
            binder << getValueOfCount();
        }
        else
        {
            binder << nullptr;
        }
    }
}
Json::Value Relations::toJson() const
{
    Json::Value ret;
    if(getId())
    {
        ret["id"]=getValueOfId();
    }
    else
    {
        ret["id"]=Json::Value();
    }
    if(getFromId())
    {
        ret["from_id"]=getValueOfFromId();
    }
    else
    {
        ret["from_id"]=Json::Value();
    }
    if(getToId())
    {
        ret["to_id"]=getValueOfToId();
    }
    else
    {
        ret["to_id"]=Json::Value();
    }
    if(getDelay())
    {
        ret["delay"]=getValueOfDelay();
    }
    else
    {
        ret["delay"]=Json::Value();
    }
    if(getDescription())
    {
        ret["description"]=getValueOfDescription();
    }
    else
    {
        ret["description"]=Json::Value();
    }
    if(getHierarchy())
    {
        ret["hierarchy"]=getValueOfHierarchy();
    }
    else
    {
        ret["hierarchy"]=Json::Value();
    }
    if(getRelates())
    {
        ret["relates"]=getValueOfRelates();
    }
    else
    {
        ret["relates"]=Json::Value();
    }
    if(getDuplicates())
    {
        ret["duplicates"]=getValueOfDuplicates();
    }
    else
    {
        ret["duplicates"]=Json::Value();
    }
    if(getBlocks())
    {
        ret["blocks"]=getValueOfBlocks();
    }
    else
    {
        ret["blocks"]=Json::Value();
    }
    if(getFollows())
    {
        ret["follows"]=getValueOfFollows();
    }
    else
    {
        ret["follows"]=Json::Value();
    }
    if(getIncludes())
    {
        ret["includes"]=getValueOfIncludes();
    }
    else
    {
        ret["includes"]=Json::Value();
    }
    if(getRequires())
    {
        ret["requires"]=getValueOfRequires();
    }
    else
    {
        ret["requires"]=Json::Value();
    }
    if(getCount())
    {
        ret["count"]=getValueOfCount();
    }
    else
    {
        ret["count"]=Json::Value();
    }
    return ret;
}

Json::Value Relations::toMasqueradedJson(
    const std::vector<std::string> &pMasqueradingVector) const
{
    Json::Value ret;
    if(pMasqueradingVector.size() == 13)
    {
        if(!pMasqueradingVector[0].empty())
        {
            if(getId())
            {
                ret[pMasqueradingVector[0]]=getValueOfId();
            }
            else
            {
                ret[pMasqueradingVector[0]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[1].empty())
        {
            if(getFromId())
            {
                ret[pMasqueradingVector[1]]=getValueOfFromId();
            }
            else
            {
                ret[pMasqueradingVector[1]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[2].empty())
        {
            if(getToId())
            {
                ret[pMasqueradingVector[2]]=getValueOfToId();
            }
            else
            {
                ret[pMasqueradingVector[2]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[3].empty())
        {
            if(getDelay())
            {
                ret[pMasqueradingVector[3]]=getValueOfDelay();
            }
            else
            {
                ret[pMasqueradingVector[3]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[4].empty())
        {
            if(getDescription())
            {
                ret[pMasqueradingVector[4]]=getValueOfDescription();
            }
            else
            {
                ret[pMasqueradingVector[4]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[5].empty())
        {
            if(getHierarchy())
            {
                ret[pMasqueradingVector[5]]=getValueOfHierarchy();
            }
            else
            {
                ret[pMasqueradingVector[5]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[6].empty())
        {
            if(getRelates())
            {
                ret[pMasqueradingVector[6]]=getValueOfRelates();
            }
            else
            {
                ret[pMasqueradingVector[6]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[7].empty())
        {
            if(getDuplicates())
            {
                ret[pMasqueradingVector[7]]=getValueOfDuplicates();
            }
            else
            {
                ret[pMasqueradingVector[7]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[8].empty())
        {
            if(getBlocks())
            {
                ret[pMasqueradingVector[8]]=getValueOfBlocks();
            }
            else
            {
                ret[pMasqueradingVector[8]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[9].empty())
        {
            if(getFollows())
            {
                ret[pMasqueradingVector[9]]=getValueOfFollows();
            }
            else
            {
                ret[pMasqueradingVector[9]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[10].empty())
        {
            if(getIncludes())
            {
                ret[pMasqueradingVector[10]]=getValueOfIncludes();
            }
            else
            {
                ret[pMasqueradingVector[10]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[11].empty())
        {
            if(getRequires())
            {
                ret[pMasqueradingVector[11]]=getValueOfRequires();
            }
            else
            {
                ret[pMasqueradingVector[11]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[12].empty())
        {
            if(getCount())
            {
                ret[pMasqueradingVector[12]]=getValueOfCount();
            }
            else
            {
                ret[pMasqueradingVector[12]]=Json::Value();
            }
        }
        return ret;
    }
    LOG_ERROR << "Masquerade failed";
    if(getId())
    {
        ret["id"]=getValueOfId();
    }
    else
    {
        ret["id"]=Json::Value();
    }
    if(getFromId())
    {
        ret["from_id"]=getValueOfFromId();
    }
    else
    {
        ret["from_id"]=Json::Value();
    }
    if(getToId())
    {
        ret["to_id"]=getValueOfToId();
    }
    else
    {
        ret["to_id"]=Json::Value();
    }
    if(getDelay())
    {
        ret["delay"]=getValueOfDelay();
    }
    else
    {
        ret["delay"]=Json::Value();
    }
    if(getDescription())
    {
        ret["description"]=getValueOfDescription();
    }
    else
    {
        ret["description"]=Json::Value();
    }
    if(getHierarchy())
    {
        ret["hierarchy"]=getValueOfHierarchy();
    }
    else
    {
        ret["hierarchy"]=Json::Value();
    }
    if(getRelates())
    {
        ret["relates"]=getValueOfRelates();
    }
    else
    {
        ret["relates"]=Json::Value();
    }
    if(getDuplicates())
    {
        ret["duplicates"]=getValueOfDuplicates();
    }
    else
    {
        ret["duplicates"]=Json::Value();
    }
    if(getBlocks())
    {
        ret["blocks"]=getValueOfBlocks();
    }
    else
    {
        ret["blocks"]=Json::Value();
    }
    if(getFollows())
    {
        ret["follows"]=getValueOfFollows();
    }
    else
    {
        ret["follows"]=Json::Value();
    }
    if(getIncludes())
    {
        ret["includes"]=getValueOfIncludes();
    }
    else
    {
        ret["includes"]=Json::Value();
    }
    if(getRequires())
    {
        ret["requires"]=getValueOfRequires();
    }
    else
    {
        ret["requires"]=Json::Value();
    }
    if(getCount())
    {
        ret["count"]=getValueOfCount();
    }
    else
    {
        ret["count"]=Json::Value();
    }
    return ret;
}

bool Relations::validateJsonForCreation(const Json::Value &pJson, std::string &err)
{
    if(pJson.isMember("id"))
    {
        if(!validJsonOfField(0, "id", pJson["id"], err, true))
            return false;
    }
    if(pJson.isMember("from_id"))
    {
        if(!validJsonOfField(1, "from_id", pJson["from_id"], err, true))
            return false;
    }
    else
    {
        err="The from_id column cannot be null";
        return false;
    }
    if(pJson.isMember("to_id"))
    {
        if(!validJsonOfField(2, "to_id", pJson["to_id"], err, true))
            return false;
    }
    else
    {
        err="The to_id column cannot be null";
        return false;
    }
    if(pJson.isMember("delay"))
    {
        if(!validJsonOfField(3, "delay", pJson["delay"], err, true))
            return false;
    }
    if(pJson.isMember("description"))
    {
        if(!validJsonOfField(4, "description", pJson["description"], err, true))
            return false;
    }
    if(pJson.isMember("hierarchy"))
    {
        if(!validJsonOfField(5, "hierarchy", pJson["hierarchy"], err, true))
            return false;
    }
    if(pJson.isMember("relates"))
    {
        if(!validJsonOfField(6, "relates", pJson["relates"], err, true))
            return false;
    }
    if(pJson.isMember("duplicates"))
    {
        if(!validJsonOfField(7, "duplicates", pJson["duplicates"], err, true))
            return false;
    }
    if(pJson.isMember("blocks"))
    {
        if(!validJsonOfField(8, "blocks", pJson["blocks"], err, true))
            return false;
    }
    if(pJson.isMember("follows"))
    {
        if(!validJsonOfField(9, "follows", pJson["follows"], err, true))
            return false;
    }
    if(pJson.isMember("includes"))
    {
        if(!validJsonOfField(10, "includes", pJson["includes"], err, true))
            return false;
    }
    if(pJson.isMember("requires"))
    {
        if(!validJsonOfField(11, "requires", pJson["requires"], err, true))
            return false;
    }
    if(pJson.isMember("count"))
    {
        if(!validJsonOfField(12, "count", pJson["count"], err, true))
            return false;
    }
    return true;
}
bool Relations::validateMasqueradedJsonForCreation(const Json::Value &pJson,
                                                   const std::vector<std::string> &pMasqueradingVector,
                                                   std::string &err)
{
    if(pMasqueradingVector.size() != 13)
    {
        err = "Bad masquerading vector";
        return false;
    }
    if(!pMasqueradingVector[0].empty())
    {
        if(pJson.isMember(pMasqueradingVector[0]))
        {
            if(!validJsonOfField(0, pMasqueradingVector[0], pJson[pMasqueradingVector[0]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[1].empty())
    {
        if(pJson.isMember(pMasqueradingVector[1]))
        {
            if(!validJsonOfField(1, pMasqueradingVector[1], pJson[pMasqueradingVector[1]], err, true))
                return false;
        }
        else
        {
            err="The " + pMasqueradingVector[1] + " column cannot be null";
            return false;
        }
    }
    if(!pMasqueradingVector[2].empty())
    {
        if(pJson.isMember(pMasqueradingVector[2]))
        {
            if(!validJsonOfField(2, pMasqueradingVector[2], pJson[pMasqueradingVector[2]], err, true))
                return false;
        }
        else
        {
            err="The " + pMasqueradingVector[2] + " column cannot be null";
            return false;
        }
    }
    if(!pMasqueradingVector[3].empty())
    {
        if(pJson.isMember(pMasqueradingVector[3]))
        {
            if(!validJsonOfField(3, pMasqueradingVector[3], pJson[pMasqueradingVector[3]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[4].empty())
    {
        if(pJson.isMember(pMasqueradingVector[4]))
        {
            if(!validJsonOfField(4, pMasqueradingVector[4], pJson[pMasqueradingVector[4]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[5].empty())
    {
        if(pJson.isMember(pMasqueradingVector[5]))
        {
            if(!validJsonOfField(5, pMasqueradingVector[5], pJson[pMasqueradingVector[5]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[6].empty())
    {
        if(pJson.isMember(pMasqueradingVector[6]))
        {
            if(!validJsonOfField(6, pMasqueradingVector[6], pJson[pMasqueradingVector[6]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[7].empty())
    {
        if(pJson.isMember(pMasqueradingVector[7]))
        {
            if(!validJsonOfField(7, pMasqueradingVector[7], pJson[pMasqueradingVector[7]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[8].empty())
    {
        if(pJson.isMember(pMasqueradingVector[8]))
        {
            if(!validJsonOfField(8, pMasqueradingVector[8], pJson[pMasqueradingVector[8]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[9].empty())
    {
        if(pJson.isMember(pMasqueradingVector[9]))
        {
            if(!validJsonOfField(9, pMasqueradingVector[9], pJson[pMasqueradingVector[9]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[10].empty())
    {
        if(pJson.isMember(pMasqueradingVector[10]))
        {
            if(!validJsonOfField(10, pMasqueradingVector[10], pJson[pMasqueradingVector[10]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[11].empty())
    {
        if(pJson.isMember(pMasqueradingVector[11]))
        {
            if(!validJsonOfField(11, pMasqueradingVector[11], pJson[pMasqueradingVector[11]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[12].empty())
    {
        if(pJson.isMember(pMasqueradingVector[12]))
        {
            if(!validJsonOfField(12, pMasqueradingVector[12], pJson[pMasqueradingVector[12]], err, true))
                return false;
        }
    }
    return true;
}
bool Relations::validateJsonForUpdate(const Json::Value &pJson, std::string &err)
{
    if(pJson.isMember("id"))
    {
        if(!validJsonOfField(0, "id", pJson["id"], err, false))
            return false;
    }
    else
    {
        err = "The value of primary key must be set in the json object for update";
        return false;
    }
    if(pJson.isMember("from_id"))
    {
        if(!validJsonOfField(1, "from_id", pJson["from_id"], err, false))
            return false;
    }
    if(pJson.isMember("to_id"))
    {
        if(!validJsonOfField(2, "to_id", pJson["to_id"], err, false))
            return false;
    }
    if(pJson.isMember("delay"))
    {
        if(!validJsonOfField(3, "delay", pJson["delay"], err, false))
            return false;
    }
    if(pJson.isMember("description"))
    {
        if(!validJsonOfField(4, "description", pJson["description"], err, false))
            return false;
    }
    if(pJson.isMember("hierarchy"))
    {
        if(!validJsonOfField(5, "hierarchy", pJson["hierarchy"], err, false))
            return false;
    }
    if(pJson.isMember("relates"))
    {
        if(!validJsonOfField(6, "relates", pJson["relates"], err, false))
            return false;
    }
    if(pJson.isMember("duplicates"))
    {
        if(!validJsonOfField(7, "duplicates", pJson["duplicates"], err, false))
            return false;
    }
    if(pJson.isMember("blocks"))
    {
        if(!validJsonOfField(8, "blocks", pJson["blocks"], err, false))
            return false;
    }
    if(pJson.isMember("follows"))
    {
        if(!validJsonOfField(9, "follows", pJson["follows"], err, false))
            return false;
    }
    if(pJson.isMember("includes"))
    {
        if(!validJsonOfField(10, "includes", pJson["includes"], err, false))
            return false;
    }
    if(pJson.isMember("requires"))
    {
        if(!validJsonOfField(11, "requires", pJson["requires"], err, false))
            return false;
    }
    if(pJson.isMember("count"))
    {
        if(!validJsonOfField(12, "count", pJson["count"], err, false))
            return false;
    }
    return true;
}
bool Relations::validateMasqueradedJsonForUpdate(const Json::Value &pJson,
                                                 const std::vector<std::string> &pMasqueradingVector,
                                                 std::string &err)
{
    if(pMasqueradingVector.size() != 13)
    {
        err = "Bad masquerading vector";
        return false;
    }
    if(!pMasqueradingVector[0].empty() && pJson.isMember(pMasqueradingVector[0]))
    {
        if(!validJsonOfField(0, pMasqueradingVector[0], pJson[pMasqueradingVector[0]], err, false))
            return false;
    }
    else
    {
        err = "The value of primary key must be set in the json object for update";
        return false;
    }
    if(!pMasqueradingVector[1].empty() && pJson.isMember(pMasqueradingVector[1]))
    {
        if(!validJsonOfField(1, pMasqueradingVector[1], pJson[pMasqueradingVector[1]], err, false))
            return false;
    }
    if(!pMasqueradingVector[2].empty() && pJson.isMember(pMasqueradingVector[2]))
    {
        if(!validJsonOfField(2, pMasqueradingVector[2], pJson[pMasqueradingVector[2]], err, false))
            return false;
    }
    if(!pMasqueradingVector[3].empty() && pJson.isMember(pMasqueradingVector[3]))
    {
        if(!validJsonOfField(3, pMasqueradingVector[3], pJson[pMasqueradingVector[3]], err, false))
            return false;
    }
    if(!pMasqueradingVector[4].empty() && pJson.isMember(pMasqueradingVector[4]))
    {
        if(!validJsonOfField(4, pMasqueradingVector[4], pJson[pMasqueradingVector[4]], err, false))
            return false;
    }
    if(!pMasqueradingVector[5].empty() && pJson.isMember(pMasqueradingVector[5]))
    {
        if(!validJsonOfField(5, pMasqueradingVector[5], pJson[pMasqueradingVector[5]], err, false))
            return false;
    }
    if(!pMasqueradingVector[6].empty() && pJson.isMember(pMasqueradingVector[6]))
    {
        if(!validJsonOfField(6, pMasqueradingVector[6], pJson[pMasqueradingVector[6]], err, false))
            return false;
    }
    if(!pMasqueradingVector[7].empty() && pJson.isMember(pMasqueradingVector[7]))
    {
        if(!validJsonOfField(7, pMasqueradingVector[7], pJson[pMasqueradingVector[7]], err, false))
            return false;
    }
    if(!pMasqueradingVector[8].empty() && pJson.isMember(pMasqueradingVector[8]))
    {
        if(!validJsonOfField(8, pMasqueradingVector[8], pJson[pMasqueradingVector[8]], err, false))
            return false;
    }
    if(!pMasqueradingVector[9].empty() && pJson.isMember(pMasqueradingVector[9]))
    {
        if(!validJsonOfField(9, pMasqueradingVector[9], pJson[pMasqueradingVector[9]], err, false))
            return false;
    }
    if(!pMasqueradingVector[10].empty() && pJson.isMember(pMasqueradingVector[10]))
    {
        if(!validJsonOfField(10, pMasqueradingVector[10], pJson[pMasqueradingVector[10]], err, false))
            return false;
    }
    if(!pMasqueradingVector[11].empty() && pJson.isMember(pMasqueradingVector[11]))
    {
        if(!validJsonOfField(11, pMasqueradingVector[11], pJson[pMasqueradingVector[11]], err, false))
            return false;
    }
    if(!pMasqueradingVector[12].empty() && pJson.isMember(pMasqueradingVector[12]))
    {
        if(!validJsonOfField(12, pMasqueradingVector[12], pJson[pMasqueradingVector[12]], err, false))
            return false;
    }
    return true;
}
bool Relations::validJsonOfField(size_t index,
                                 const std::string &fieldName,
                                 const Json::Value &pJson, 
                                 std::string &err, 
                                 bool isForCreation)
{
    switch(index)
    {
        case 0:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(isForCreation)
            {
                err="The automatic primary key cannot be set";
                return false;
            }        
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 1:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 2:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 3:
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 4:
            if(!pJson.isString() && !pJson.isNull())
            {
                err="Type error in the "+fieldName+"field";
                return false;                
            }
            break;
        case 5:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 6:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 7:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 8:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 9:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 10:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 11:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 12:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
     
        default:
            err="Internal error in the server";
            return false;
            break;
    }
    return true;
}
