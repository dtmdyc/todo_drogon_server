/**
 *
 *  LaborBudgetItems.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */

#include "LaborBudgetItems.h"
#include <drogon/utils/Utilities.h>
#include <string>

using namespace drogon;
using namespace drogon_model::openproject4;

const std::string LaborBudgetItems::Cols::_id = "id";
const std::string LaborBudgetItems::Cols::_cost_object_id = "cost_object_id";
const std::string LaborBudgetItems::Cols::_hours = "hours";
const std::string LaborBudgetItems::Cols::_user_id = "user_id";
const std::string LaborBudgetItems::Cols::_comments = "comments";
const std::string LaborBudgetItems::Cols::_budget = "budget";
const std::string LaborBudgetItems::primaryKeyName = "id";
const bool LaborBudgetItems::hasPrimaryKey = true;
const std::string LaborBudgetItems::tableName = "labor_budget_items";

const std::vector<typename LaborBudgetItems::MetaData> LaborBudgetItems::_metaData={
{"id","int32_t","integer",4,1,1,1},
{"cost_object_id","int32_t","integer",4,0,0,1},
{"hours","double","double precision",8,0,0,1},
{"user_id","int32_t","integer",4,0,0,0},
{"comments","std::string","character varying",0,0,0,1},
{"budget","int64_t","numeric",8,0,0,0}
};
const std::string &LaborBudgetItems::getColumnName(size_t index) noexcept(false)
{
    assert(index < _metaData.size());
    return _metaData[index]._colName;
}
LaborBudgetItems::LaborBudgetItems(const Row &r) noexcept
{
        if(!r["id"].isNull())
        {
            _id=std::make_shared<int32_t>(r["id"].as<int32_t>());
        }
        if(!r["cost_object_id"].isNull())
        {
            _costObjectId=std::make_shared<int32_t>(r["cost_object_id"].as<int32_t>());
        }
        if(!r["hours"].isNull())
        {
            _hours=std::make_shared<double>(r["hours"].as<double>());
        }
        if(!r["user_id"].isNull())
        {
            _userId=std::make_shared<int32_t>(r["user_id"].as<int32_t>());
        }
        if(!r["comments"].isNull())
        {
            _comments=std::make_shared<std::string>(r["comments"].as<std::string>());
        }
        if(!r["budget"].isNull())
        {
            _budget=std::make_shared<int64_t>(r["budget"].as<int64_t>());
        }
}
const int32_t &LaborBudgetItems::getValueOfId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_id)
        return *_id;
    return defaultValue;
}
const std::shared_ptr<int32_t> &LaborBudgetItems::getId() const noexcept
{
    return _id;
}
const typename LaborBudgetItems::PrimaryKeyType & LaborBudgetItems::getPrimaryKey() const
{
    assert(_id);
    return *_id;
}

const int32_t &LaborBudgetItems::getValueOfCostObjectId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_costObjectId)
        return *_costObjectId;
    return defaultValue;
}
const std::shared_ptr<int32_t> &LaborBudgetItems::getCostObjectId() const noexcept
{
    return _costObjectId;
}
void LaborBudgetItems::setCostObjectId(const int32_t &pCostObjectId) noexcept
{
    _costObjectId = std::make_shared<int32_t>(pCostObjectId);
    _dirtyFlag[1] = true;
}


const double &LaborBudgetItems::getValueOfHours() const noexcept
{
    const static double defaultValue = double();
    if(_hours)
        return *_hours;
    return defaultValue;
}
const std::shared_ptr<double> &LaborBudgetItems::getHours() const noexcept
{
    return _hours;
}
void LaborBudgetItems::setHours(const double &pHours) noexcept
{
    _hours = std::make_shared<double>(pHours);
    _dirtyFlag[2] = true;
}


const int32_t &LaborBudgetItems::getValueOfUserId() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_userId)
        return *_userId;
    return defaultValue;
}
const std::shared_ptr<int32_t> &LaborBudgetItems::getUserId() const noexcept
{
    return _userId;
}
void LaborBudgetItems::setUserId(const int32_t &pUserId) noexcept
{
    _userId = std::make_shared<int32_t>(pUserId);
    _dirtyFlag[3] = true;
}


const std::string &LaborBudgetItems::getValueOfComments() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_comments)
        return *_comments;
    return defaultValue;
}
const std::shared_ptr<std::string> &LaborBudgetItems::getComments() const noexcept
{
    return _comments;
}
void LaborBudgetItems::setComments(const std::string &pComments) noexcept
{
    _comments = std::make_shared<std::string>(pComments);
    _dirtyFlag[4] = true;
}
void LaborBudgetItems::setComments(std::string &&pComments) noexcept
{
    _comments = std::make_shared<std::string>(std::move(pComments));
    _dirtyFlag[4] = true;
}


const int64_t &LaborBudgetItems::getValueOfBudget() const noexcept
{
    const static int64_t defaultValue = int64_t();
    if(_budget)
        return *_budget;
    return defaultValue;
}
const std::shared_ptr<int64_t> &LaborBudgetItems::getBudget() const noexcept
{
    return _budget;
}
void LaborBudgetItems::setBudget(const int64_t &pBudget) noexcept
{
    _budget = std::make_shared<int64_t>(pBudget);
    _dirtyFlag[5] = true;
}


void LaborBudgetItems::updateId(const uint64_t id)
{
}

const std::vector<std::string> &LaborBudgetItems::insertColumns() noexcept
{
    static const std::vector<std::string> _inCols={
        "cost_object_id",
        "hours",
        "user_id",
        "comments",
        "budget"
    };
    return _inCols;
}

void LaborBudgetItems::outputArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(getCostObjectId())
    {
        binder << getValueOfCostObjectId();
    }
    else
    {
        binder << nullptr;
    }
    if(getHours())
    {
        binder << getValueOfHours();
    }
    else
    {
        binder << nullptr;
    }
    if(getUserId())
    {
        binder << getValueOfUserId();
    }
    else
    {
        binder << nullptr;
    }
    if(getComments())
    {
        binder << getValueOfComments();
    }
    else
    {
        binder << nullptr;
    }
    if(getBudget())
    {
        binder << getValueOfBudget();
    }
    else
    {
        binder << nullptr;
    }
}

const std::vector<std::string> LaborBudgetItems::updateColumns() const
{
    std::vector<std::string> ret;
    for(size_t i=0;i<sizeof(_dirtyFlag);i++)
    {
        if(_dirtyFlag[i])
        {
            ret.push_back(getColumnName(i));
        }
    }
    return ret;
}

void LaborBudgetItems::updateArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(_dirtyFlag[1])
    {
        if(getCostObjectId())
        {
            binder << getValueOfCostObjectId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[2])
    {
        if(getHours())
        {
            binder << getValueOfHours();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[3])
    {
        if(getUserId())
        {
            binder << getValueOfUserId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[4])
    {
        if(getComments())
        {
            binder << getValueOfComments();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[5])
    {
        if(getBudget())
        {
            binder << getValueOfBudget();
        }
        else
        {
            binder << nullptr;
        }
    }
}
Json::Value LaborBudgetItems::toJson() const
{
    Json::Value ret;
    if(getId())
    {
        ret["id"]=getValueOfId();
    }
    else
    {
        ret["id"]=Json::Value();
    }
    if(getCostObjectId())
    {
        ret["cost_object_id"]=getValueOfCostObjectId();
    }
    else
    {
        ret["cost_object_id"]=Json::Value();
    }
    if(getHours())
    {
        ret["hours"]=getValueOfHours();
    }
    else
    {
        ret["hours"]=Json::Value();
    }
    if(getUserId())
    {
        ret["user_id"]=getValueOfUserId();
    }
    else
    {
        ret["user_id"]=Json::Value();
    }
    if(getComments())
    {
        ret["comments"]=getValueOfComments();
    }
    else
    {
        ret["comments"]=Json::Value();
    }
    if(getBudget())
    {
        ret["budget"]=(Json::Int64)getValueOfBudget();
    }
    else
    {
        ret["budget"]=Json::Value();
    }
    return ret;
}
