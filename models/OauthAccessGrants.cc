/**
 *
 *  OauthAccessGrants.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl
 *
 */

#include "OauthAccessGrants.h"
#include <drogon/utils/Utilities.h>
#include <string>

using namespace drogon;
using namespace drogon_model::openproject6;

const std::string OauthAccessGrants::Cols::_id = "id";
const std::string OauthAccessGrants::Cols::_resource_owner_id = "resource_owner_id";
const std::string OauthAccessGrants::Cols::_application_id = "application_id";
const std::string OauthAccessGrants::Cols::_token = "token";
const std::string OauthAccessGrants::Cols::_expires_in = "expires_in";
const std::string OauthAccessGrants::Cols::_redirect_uri = "redirect_uri";
const std::string OauthAccessGrants::Cols::_created_at = "created_at";
const std::string OauthAccessGrants::Cols::_revoked_at = "revoked_at";
const std::string OauthAccessGrants::Cols::_scopes = "scopes";
const std::string OauthAccessGrants::Cols::_code_challenge = "code_challenge";
const std::string OauthAccessGrants::Cols::_code_challenge_method = "code_challenge_method";
const std::string OauthAccessGrants::primaryKeyName = "id";
const bool OauthAccessGrants::hasPrimaryKey = true;
const std::string OauthAccessGrants::tableName = "oauth_access_grants";

const std::vector<typename OauthAccessGrants::MetaData> OauthAccessGrants::_metaData={
{"id","int64_t","bigint",8,1,1,1},
{"resource_owner_id","int64_t","bigint",8,0,0,1},
{"application_id","int64_t","bigint",8,0,0,1},
{"token","std::string","character varying",0,0,0,1},
{"expires_in","int32_t","integer",4,0,0,1},
{"redirect_uri","std::string","text",0,0,0,1},
{"created_at","::trantor::Date","timestamp without time zone",0,0,0,1},
{"revoked_at","::trantor::Date","timestamp without time zone",0,0,0,0},
{"scopes","std::string","character varying",0,0,0,0},
{"code_challenge","std::string","character varying",0,0,0,0},
{"code_challenge_method","std::string","character varying",0,0,0,0}
};
const std::string &OauthAccessGrants::getColumnName(size_t index) noexcept(false)
{
    assert(index < _metaData.size());
    return _metaData[index]._colName;
}
OauthAccessGrants::OauthAccessGrants(const Row &r, const ssize_t indexOffset) noexcept
{
    if(indexOffset < 0)
    {
        if(!r["id"].isNull())
        {
            _id=std::make_shared<int64_t>(r["id"].as<int64_t>());
        }
        if(!r["resource_owner_id"].isNull())
        {
            _resourceOwnerId=std::make_shared<int64_t>(r["resource_owner_id"].as<int64_t>());
        }
        if(!r["application_id"].isNull())
        {
            _applicationId=std::make_shared<int64_t>(r["application_id"].as<int64_t>());
        }
        if(!r["token"].isNull())
        {
            _token=std::make_shared<std::string>(r["token"].as<std::string>());
        }
        if(!r["expires_in"].isNull())
        {
            _expiresIn=std::make_shared<int32_t>(r["expires_in"].as<int32_t>());
        }
        if(!r["redirect_uri"].isNull())
        {
            _redirectUri=std::make_shared<std::string>(r["redirect_uri"].as<std::string>());
        }
        if(!r["created_at"].isNull())
        {
            auto timeStr = r["created_at"].as<std::string>();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            size_t t = timelocal(&stm);
            size_t decimalNum = 0;
            if(*p=='.')
            {
                std::string decimals(p+1,&timeStr[timeStr.length()]);
                while(decimals.length()<6)
                {
                    decimals += "0";
                }
                decimalNum = (size_t)atol(decimals.c_str());
            }
            _createdAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
        }
        if(!r["revoked_at"].isNull())
        {
            auto timeStr = r["revoked_at"].as<std::string>();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            size_t t = timelocal(&stm);
            size_t decimalNum = 0;
            if(*p=='.')
            {
                std::string decimals(p+1,&timeStr[timeStr.length()]);
                while(decimals.length()<6)
                {
                    decimals += "0";
                }
                decimalNum = (size_t)atol(decimals.c_str());
            }
            _revokedAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
        }
        if(!r["scopes"].isNull())
        {
            _scopes=std::make_shared<std::string>(r["scopes"].as<std::string>());
        }
        if(!r["code_challenge"].isNull())
        {
            _codeChallenge=std::make_shared<std::string>(r["code_challenge"].as<std::string>());
        }
        if(!r["code_challenge_method"].isNull())
        {
            _codeChallengeMethod=std::make_shared<std::string>(r["code_challenge_method"].as<std::string>());
        }
    }
    else
    {
        size_t offset = (size_t)indexOffset;
        if(offset + 11 > r.size())
        {
            LOG_FATAL << "Invalid SQL result for this model";
            return;
        }
        size_t index;
        index = offset + 0;
        if(!r[index].isNull())
        {
            _id=std::make_shared<int64_t>(r[index].as<int64_t>());
        }
        index = offset + 1;
        if(!r[index].isNull())
        {
            _resourceOwnerId=std::make_shared<int64_t>(r[index].as<int64_t>());
        }
        index = offset + 2;
        if(!r[index].isNull())
        {
            _applicationId=std::make_shared<int64_t>(r[index].as<int64_t>());
        }
        index = offset + 3;
        if(!r[index].isNull())
        {
            _token=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 4;
        if(!r[index].isNull())
        {
            _expiresIn=std::make_shared<int32_t>(r[index].as<int32_t>());
        }
        index = offset + 5;
        if(!r[index].isNull())
        {
            _redirectUri=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 6;
        if(!r[index].isNull())
        {
            auto timeStr = r[index].as<std::string>();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            size_t t = timelocal(&stm);
            size_t decimalNum = 0;
            if(*p=='.')
            {
                std::string decimals(p+1,&timeStr[timeStr.length()]);
                while(decimals.length()<6)
                {
                    decimals += "0";
                }
                decimalNum = (size_t)atol(decimals.c_str());
            }
            _createdAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
        }
        index = offset + 7;
        if(!r[index].isNull())
        {
            auto timeStr = r[index].as<std::string>();
            struct tm stm;
            memset(&stm,0,sizeof(stm));
            auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
            size_t t = timelocal(&stm);
            size_t decimalNum = 0;
            if(*p=='.')
            {
                std::string decimals(p+1,&timeStr[timeStr.length()]);
                while(decimals.length()<6)
                {
                    decimals += "0";
                }
                decimalNum = (size_t)atol(decimals.c_str());
            }
            _revokedAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
        }
        index = offset + 8;
        if(!r[index].isNull())
        {
            _scopes=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 9;
        if(!r[index].isNull())
        {
            _codeChallenge=std::make_shared<std::string>(r[index].as<std::string>());
        }
        index = offset + 10;
        if(!r[index].isNull())
        {
            _codeChallengeMethod=std::make_shared<std::string>(r[index].as<std::string>());
        }
    }

}

OauthAccessGrants::OauthAccessGrants(const Json::Value &pJson, const std::vector<std::string> &pMasqueradingVector) noexcept(false)
{
    if(pMasqueradingVector.size() != 11)
    {
        LOG_ERROR << "Bad masquerading vector";
        return;
    }
    if(!pMasqueradingVector[0].empty() && pJson.isMember(pMasqueradingVector[0]))
    {
        _id=std::make_shared<int64_t>((int64_t)pJson[pMasqueradingVector[0]].asInt64());
    }
    if(!pMasqueradingVector[1].empty() && pJson.isMember(pMasqueradingVector[1]))
    {
        _resourceOwnerId=std::make_shared<int64_t>((int64_t)pJson[pMasqueradingVector[1]].asInt64());
    }
    if(!pMasqueradingVector[2].empty() && pJson.isMember(pMasqueradingVector[2]))
    {
        _applicationId=std::make_shared<int64_t>((int64_t)pJson[pMasqueradingVector[2]].asInt64());
    }
    if(!pMasqueradingVector[3].empty() && pJson.isMember(pMasqueradingVector[3]))
    {
        _token=std::make_shared<std::string>(pJson[pMasqueradingVector[3]].asString());
    }
    if(!pMasqueradingVector[4].empty() && pJson.isMember(pMasqueradingVector[4]))
    {
        _expiresIn=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[4]].asInt64());
    }
    if(!pMasqueradingVector[5].empty() && pJson.isMember(pMasqueradingVector[5]))
    {
        _redirectUri=std::make_shared<std::string>(pJson[pMasqueradingVector[5]].asString());
    }
    if(!pMasqueradingVector[6].empty() && pJson.isMember(pMasqueradingVector[6]))
    {
        auto timeStr = pJson[pMasqueradingVector[6]].asString();
        struct tm stm;
        memset(&stm,0,sizeof(stm));
        auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
        size_t t = timelocal(&stm);
        size_t decimalNum = 0;
        if(*p=='.')
        {
            std::string decimals(p+1,&timeStr[timeStr.length()]);
            while(decimals.length()<6)
            {
                decimals += "0";
            }
            decimalNum = (size_t)atol(decimals.c_str());
        }
        _createdAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
    }
    if(!pMasqueradingVector[7].empty() && pJson.isMember(pMasqueradingVector[7]))
    {
        auto timeStr = pJson[pMasqueradingVector[7]].asString();
        struct tm stm;
        memset(&stm,0,sizeof(stm));
        auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
        size_t t = timelocal(&stm);
        size_t decimalNum = 0;
        if(*p=='.')
        {
            std::string decimals(p+1,&timeStr[timeStr.length()]);
            while(decimals.length()<6)
            {
                decimals += "0";
            }
            decimalNum = (size_t)atol(decimals.c_str());
        }
        _revokedAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
    }
    if(!pMasqueradingVector[8].empty() && pJson.isMember(pMasqueradingVector[8]))
    {
        _scopes=std::make_shared<std::string>(pJson[pMasqueradingVector[8]].asString());
    }
    if(!pMasqueradingVector[9].empty() && pJson.isMember(pMasqueradingVector[9]))
    {
        _codeChallenge=std::make_shared<std::string>(pJson[pMasqueradingVector[9]].asString());
    }
    if(!pMasqueradingVector[10].empty() && pJson.isMember(pMasqueradingVector[10]))
    {
        _codeChallengeMethod=std::make_shared<std::string>(pJson[pMasqueradingVector[10]].asString());
    }
}

OauthAccessGrants::OauthAccessGrants(const Json::Value &pJson) noexcept(false)
{
    if(pJson.isMember("id"))
    {
        _id=std::make_shared<int64_t>((int64_t)pJson["id"].asInt64());
    }
    if(pJson.isMember("resource_owner_id"))
    {
        _resourceOwnerId=std::make_shared<int64_t>((int64_t)pJson["resource_owner_id"].asInt64());
    }
    if(pJson.isMember("application_id"))
    {
        _applicationId=std::make_shared<int64_t>((int64_t)pJson["application_id"].asInt64());
    }
    if(pJson.isMember("token"))
    {
        _token=std::make_shared<std::string>(pJson["token"].asString());
    }
    if(pJson.isMember("expires_in"))
    {
        _expiresIn=std::make_shared<int32_t>((int32_t)pJson["expires_in"].asInt64());
    }
    if(pJson.isMember("redirect_uri"))
    {
        _redirectUri=std::make_shared<std::string>(pJson["redirect_uri"].asString());
    }
    if(pJson.isMember("created_at"))
    {
        auto timeStr = pJson["created_at"].asString();
        struct tm stm;
        memset(&stm,0,sizeof(stm));
        auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
        size_t t = timelocal(&stm);
        size_t decimalNum = 0;
        if(*p=='.')
        {
            std::string decimals(p+1,&timeStr[timeStr.length()]);
            while(decimals.length()<6)
            {
                decimals += "0";
            }
            decimalNum = (size_t)atol(decimals.c_str());
        }
        _createdAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
    }
    if(pJson.isMember("revoked_at"))
    {
        auto timeStr = pJson["revoked_at"].asString();
        struct tm stm;
        memset(&stm,0,sizeof(stm));
        auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
        size_t t = timelocal(&stm);
        size_t decimalNum = 0;
        if(*p=='.')
        {
            std::string decimals(p+1,&timeStr[timeStr.length()]);
            while(decimals.length()<6)
            {
                decimals += "0";
            }
            decimalNum = (size_t)atol(decimals.c_str());
        }
        _revokedAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
    }
    if(pJson.isMember("scopes"))
    {
        _scopes=std::make_shared<std::string>(pJson["scopes"].asString());
    }
    if(pJson.isMember("code_challenge"))
    {
        _codeChallenge=std::make_shared<std::string>(pJson["code_challenge"].asString());
    }
    if(pJson.isMember("code_challenge_method"))
    {
        _codeChallengeMethod=std::make_shared<std::string>(pJson["code_challenge_method"].asString());
    }
}

void OauthAccessGrants::updateByMasqueradedJson(const Json::Value &pJson,
                                            const std::vector<std::string> &pMasqueradingVector) noexcept(false)
{
    if(pMasqueradingVector.size() != 11)
    {
        LOG_ERROR << "Bad masquerading vector";
        return;
    }
    if(!pMasqueradingVector[0].empty() && pJson.isMember(pMasqueradingVector[0]))
    {
        _id=std::make_shared<int64_t>((int64_t)pJson[pMasqueradingVector[0]].asInt64());
    }
    if(!pMasqueradingVector[1].empty() && pJson.isMember(pMasqueradingVector[1]))
    {
        _dirtyFlag[1] = true;
        _resourceOwnerId=std::make_shared<int64_t>((int64_t)pJson[pMasqueradingVector[1]].asInt64());
    }
    if(!pMasqueradingVector[2].empty() && pJson.isMember(pMasqueradingVector[2]))
    {
        _dirtyFlag[2] = true;
        _applicationId=std::make_shared<int64_t>((int64_t)pJson[pMasqueradingVector[2]].asInt64());
    }
    if(!pMasqueradingVector[3].empty() && pJson.isMember(pMasqueradingVector[3]))
    {
        _dirtyFlag[3] = true;
        _token=std::make_shared<std::string>(pJson[pMasqueradingVector[3]].asString());
    }
    if(!pMasqueradingVector[4].empty() && pJson.isMember(pMasqueradingVector[4]))
    {
        _dirtyFlag[4] = true;
        _expiresIn=std::make_shared<int32_t>((int32_t)pJson[pMasqueradingVector[4]].asInt64());
    }
    if(!pMasqueradingVector[5].empty() && pJson.isMember(pMasqueradingVector[5]))
    {
        _dirtyFlag[5] = true;
        _redirectUri=std::make_shared<std::string>(pJson[pMasqueradingVector[5]].asString());
    }
    if(!pMasqueradingVector[6].empty() && pJson.isMember(pMasqueradingVector[6]))
    {
        _dirtyFlag[6] = true;
        auto timeStr = pJson[pMasqueradingVector[6]].asString();
        struct tm stm;
        memset(&stm,0,sizeof(stm));
        auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
        size_t t = timelocal(&stm);
        size_t decimalNum = 0;
        if(*p=='.')
        {
            std::string decimals(p+1,&timeStr[timeStr.length()]);
            while(decimals.length()<6)
            {
                decimals += "0";
            }
            decimalNum = (size_t)atol(decimals.c_str());
        }
        _createdAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
    }
    if(!pMasqueradingVector[7].empty() && pJson.isMember(pMasqueradingVector[7]))
    {
        _dirtyFlag[7] = true;
        auto timeStr = pJson[pMasqueradingVector[7]].asString();
        struct tm stm;
        memset(&stm,0,sizeof(stm));
        auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
        size_t t = timelocal(&stm);
        size_t decimalNum = 0;
        if(*p=='.')
        {
            std::string decimals(p+1,&timeStr[timeStr.length()]);
            while(decimals.length()<6)
            {
                decimals += "0";
            }
            decimalNum = (size_t)atol(decimals.c_str());
        }
        _revokedAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
    }
    if(!pMasqueradingVector[8].empty() && pJson.isMember(pMasqueradingVector[8]))
    {
        _dirtyFlag[8] = true;
        _scopes=std::make_shared<std::string>(pJson[pMasqueradingVector[8]].asString());
    }
    if(!pMasqueradingVector[9].empty() && pJson.isMember(pMasqueradingVector[9]))
    {
        _dirtyFlag[9] = true;
        _codeChallenge=std::make_shared<std::string>(pJson[pMasqueradingVector[9]].asString());
    }
    if(!pMasqueradingVector[10].empty() && pJson.isMember(pMasqueradingVector[10]))
    {
        _dirtyFlag[10] = true;
        _codeChallengeMethod=std::make_shared<std::string>(pJson[pMasqueradingVector[10]].asString());
    }
}
                                                                    
void OauthAccessGrants::updateByJson(const Json::Value &pJson) noexcept(false)
{
    if(pJson.isMember("id"))
    {
        _id=std::make_shared<int64_t>((int64_t)pJson["id"].asInt64());
    }
    if(pJson.isMember("resource_owner_id"))
    {
        _dirtyFlag[1] = true;
        _resourceOwnerId=std::make_shared<int64_t>((int64_t)pJson["resource_owner_id"].asInt64());
    }
    if(pJson.isMember("application_id"))
    {
        _dirtyFlag[2] = true;
        _applicationId=std::make_shared<int64_t>((int64_t)pJson["application_id"].asInt64());
    }
    if(pJson.isMember("token"))
    {
        _dirtyFlag[3] = true;
        _token=std::make_shared<std::string>(pJson["token"].asString());
    }
    if(pJson.isMember("expires_in"))
    {
        _dirtyFlag[4] = true;
        _expiresIn=std::make_shared<int32_t>((int32_t)pJson["expires_in"].asInt64());
    }
    if(pJson.isMember("redirect_uri"))
    {
        _dirtyFlag[5] = true;
        _redirectUri=std::make_shared<std::string>(pJson["redirect_uri"].asString());
    }
    if(pJson.isMember("created_at"))
    {
        _dirtyFlag[6] = true;
        auto timeStr = pJson["created_at"].asString();
        struct tm stm;
        memset(&stm,0,sizeof(stm));
        auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
        size_t t = timelocal(&stm);
        size_t decimalNum = 0;
        if(*p=='.')
        {
            std::string decimals(p+1,&timeStr[timeStr.length()]);
            while(decimals.length()<6)
            {
                decimals += "0";
            }
            decimalNum = (size_t)atol(decimals.c_str());
        }
        _createdAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
    }
    if(pJson.isMember("revoked_at"))
    {
        _dirtyFlag[7] = true;
        auto timeStr = pJson["revoked_at"].asString();
        struct tm stm;
        memset(&stm,0,sizeof(stm));
        auto p = strptime(timeStr.c_str(),"%Y-%m-%d %H:%M:%S",&stm);
        size_t t = timelocal(&stm);
        size_t decimalNum = 0;
        if(*p=='.')
        {
            std::string decimals(p+1,&timeStr[timeStr.length()]);
            while(decimals.length()<6)
            {
                decimals += "0";
            }
            decimalNum = (size_t)atol(decimals.c_str());
        }
        _revokedAt=std::make_shared<::trantor::Date>(t*1000000+decimalNum);
    }
    if(pJson.isMember("scopes"))
    {
        _dirtyFlag[8] = true;
        _scopes=std::make_shared<std::string>(pJson["scopes"].asString());
    }
    if(pJson.isMember("code_challenge"))
    {
        _dirtyFlag[9] = true;
        _codeChallenge=std::make_shared<std::string>(pJson["code_challenge"].asString());
    }
    if(pJson.isMember("code_challenge_method"))
    {
        _dirtyFlag[10] = true;
        _codeChallengeMethod=std::make_shared<std::string>(pJson["code_challenge_method"].asString());
    }
}

const int64_t &OauthAccessGrants::getValueOfId() const noexcept
{
    const static int64_t defaultValue = int64_t();
    if(_id)
        return *_id;
    return defaultValue;
}
const std::shared_ptr<int64_t> &OauthAccessGrants::getId() const noexcept
{
    return _id;
}
const typename OauthAccessGrants::PrimaryKeyType & OauthAccessGrants::getPrimaryKey() const
{
    assert(_id);
    return *_id;
}

const int64_t &OauthAccessGrants::getValueOfResourceOwnerId() const noexcept
{
    const static int64_t defaultValue = int64_t();
    if(_resourceOwnerId)
        return *_resourceOwnerId;
    return defaultValue;
}
const std::shared_ptr<int64_t> &OauthAccessGrants::getResourceOwnerId() const noexcept
{
    return _resourceOwnerId;
}
void OauthAccessGrants::setResourceOwnerId(const int64_t &pResourceOwnerId) noexcept
{
    _resourceOwnerId = std::make_shared<int64_t>(pResourceOwnerId);
    _dirtyFlag[1] = true;
}


const int64_t &OauthAccessGrants::getValueOfApplicationId() const noexcept
{
    const static int64_t defaultValue = int64_t();
    if(_applicationId)
        return *_applicationId;
    return defaultValue;
}
const std::shared_ptr<int64_t> &OauthAccessGrants::getApplicationId() const noexcept
{
    return _applicationId;
}
void OauthAccessGrants::setApplicationId(const int64_t &pApplicationId) noexcept
{
    _applicationId = std::make_shared<int64_t>(pApplicationId);
    _dirtyFlag[2] = true;
}


const std::string &OauthAccessGrants::getValueOfToken() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_token)
        return *_token;
    return defaultValue;
}
const std::shared_ptr<std::string> &OauthAccessGrants::getToken() const noexcept
{
    return _token;
}
void OauthAccessGrants::setToken(const std::string &pToken) noexcept
{
    _token = std::make_shared<std::string>(pToken);
    _dirtyFlag[3] = true;
}
void OauthAccessGrants::setToken(std::string &&pToken) noexcept
{
    _token = std::make_shared<std::string>(std::move(pToken));
    _dirtyFlag[3] = true;
}


const int32_t &OauthAccessGrants::getValueOfExpiresIn() const noexcept
{
    const static int32_t defaultValue = int32_t();
    if(_expiresIn)
        return *_expiresIn;
    return defaultValue;
}
const std::shared_ptr<int32_t> &OauthAccessGrants::getExpiresIn() const noexcept
{
    return _expiresIn;
}
void OauthAccessGrants::setExpiresIn(const int32_t &pExpiresIn) noexcept
{
    _expiresIn = std::make_shared<int32_t>(pExpiresIn);
    _dirtyFlag[4] = true;
}


const std::string &OauthAccessGrants::getValueOfRedirectUri() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_redirectUri)
        return *_redirectUri;
    return defaultValue;
}
const std::shared_ptr<std::string> &OauthAccessGrants::getRedirectUri() const noexcept
{
    return _redirectUri;
}
void OauthAccessGrants::setRedirectUri(const std::string &pRedirectUri) noexcept
{
    _redirectUri = std::make_shared<std::string>(pRedirectUri);
    _dirtyFlag[5] = true;
}
void OauthAccessGrants::setRedirectUri(std::string &&pRedirectUri) noexcept
{
    _redirectUri = std::make_shared<std::string>(std::move(pRedirectUri));
    _dirtyFlag[5] = true;
}


const ::trantor::Date &OauthAccessGrants::getValueOfCreatedAt() const noexcept
{
    const static ::trantor::Date defaultValue = ::trantor::Date();
    if(_createdAt)
        return *_createdAt;
    return defaultValue;
}
const std::shared_ptr<::trantor::Date> &OauthAccessGrants::getCreatedAt() const noexcept
{
    return _createdAt;
}
void OauthAccessGrants::setCreatedAt(const ::trantor::Date &pCreatedAt) noexcept
{
    _createdAt = std::make_shared<::trantor::Date>(pCreatedAt);
    _dirtyFlag[6] = true;
}


const ::trantor::Date &OauthAccessGrants::getValueOfRevokedAt() const noexcept
{
    const static ::trantor::Date defaultValue = ::trantor::Date();
    if(_revokedAt)
        return *_revokedAt;
    return defaultValue;
}
const std::shared_ptr<::trantor::Date> &OauthAccessGrants::getRevokedAt() const noexcept
{
    return _revokedAt;
}
void OauthAccessGrants::setRevokedAt(const ::trantor::Date &pRevokedAt) noexcept
{
    _revokedAt = std::make_shared<::trantor::Date>(pRevokedAt);
    _dirtyFlag[7] = true;
}


const std::string &OauthAccessGrants::getValueOfScopes() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_scopes)
        return *_scopes;
    return defaultValue;
}
const std::shared_ptr<std::string> &OauthAccessGrants::getScopes() const noexcept
{
    return _scopes;
}
void OauthAccessGrants::setScopes(const std::string &pScopes) noexcept
{
    _scopes = std::make_shared<std::string>(pScopes);
    _dirtyFlag[8] = true;
}
void OauthAccessGrants::setScopes(std::string &&pScopes) noexcept
{
    _scopes = std::make_shared<std::string>(std::move(pScopes));
    _dirtyFlag[8] = true;
}


const std::string &OauthAccessGrants::getValueOfCodeChallenge() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_codeChallenge)
        return *_codeChallenge;
    return defaultValue;
}
const std::shared_ptr<std::string> &OauthAccessGrants::getCodeChallenge() const noexcept
{
    return _codeChallenge;
}
void OauthAccessGrants::setCodeChallenge(const std::string &pCodeChallenge) noexcept
{
    _codeChallenge = std::make_shared<std::string>(pCodeChallenge);
    _dirtyFlag[9] = true;
}
void OauthAccessGrants::setCodeChallenge(std::string &&pCodeChallenge) noexcept
{
    _codeChallenge = std::make_shared<std::string>(std::move(pCodeChallenge));
    _dirtyFlag[9] = true;
}


const std::string &OauthAccessGrants::getValueOfCodeChallengeMethod() const noexcept
{
    const static std::string defaultValue = std::string();
    if(_codeChallengeMethod)
        return *_codeChallengeMethod;
    return defaultValue;
}
const std::shared_ptr<std::string> &OauthAccessGrants::getCodeChallengeMethod() const noexcept
{
    return _codeChallengeMethod;
}
void OauthAccessGrants::setCodeChallengeMethod(const std::string &pCodeChallengeMethod) noexcept
{
    _codeChallengeMethod = std::make_shared<std::string>(pCodeChallengeMethod);
    _dirtyFlag[10] = true;
}
void OauthAccessGrants::setCodeChallengeMethod(std::string &&pCodeChallengeMethod) noexcept
{
    _codeChallengeMethod = std::make_shared<std::string>(std::move(pCodeChallengeMethod));
    _dirtyFlag[10] = true;
}


void OauthAccessGrants::updateId(const uint64_t id)
{
}

const std::vector<std::string> &OauthAccessGrants::insertColumns() noexcept
{
    static const std::vector<std::string> _inCols={
        "resource_owner_id",
        "application_id",
        "token",
        "expires_in",
        "redirect_uri",
        "created_at",
        "revoked_at",
        "scopes",
        "code_challenge",
        "code_challenge_method"
    };
    return _inCols;
}

void OauthAccessGrants::outputArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(getResourceOwnerId())
    {
        binder << getValueOfResourceOwnerId();
    }
    else
    {
        binder << nullptr;
    }
    if(getApplicationId())
    {
        binder << getValueOfApplicationId();
    }
    else
    {
        binder << nullptr;
    }
    if(getToken())
    {
        binder << getValueOfToken();
    }
    else
    {
        binder << nullptr;
    }
    if(getExpiresIn())
    {
        binder << getValueOfExpiresIn();
    }
    else
    {
        binder << nullptr;
    }
    if(getRedirectUri())
    {
        binder << getValueOfRedirectUri();
    }
    else
    {
        binder << nullptr;
    }
    if(getCreatedAt())
    {
        binder << getValueOfCreatedAt();
    }
    else
    {
        binder << nullptr;
    }
    if(getRevokedAt())
    {
        binder << getValueOfRevokedAt();
    }
    else
    {
        binder << nullptr;
    }
    if(getScopes())
    {
        binder << getValueOfScopes();
    }
    else
    {
        binder << nullptr;
    }
    if(getCodeChallenge())
    {
        binder << getValueOfCodeChallenge();
    }
    else
    {
        binder << nullptr;
    }
    if(getCodeChallengeMethod())
    {
        binder << getValueOfCodeChallengeMethod();
    }
    else
    {
        binder << nullptr;
    }
}

const std::vector<std::string> OauthAccessGrants::updateColumns() const
{
    std::vector<std::string> ret;
    for(size_t i=0;i<sizeof(_dirtyFlag);i++)
    {
        if(_dirtyFlag[i])
        {
            ret.push_back(getColumnName(i));
        }
    }
    return ret;
}

void OauthAccessGrants::updateArgs(drogon::orm::internal::SqlBinder &binder) const
{
    if(_dirtyFlag[1])
    {
        if(getResourceOwnerId())
        {
            binder << getValueOfResourceOwnerId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[2])
    {
        if(getApplicationId())
        {
            binder << getValueOfApplicationId();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[3])
    {
        if(getToken())
        {
            binder << getValueOfToken();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[4])
    {
        if(getExpiresIn())
        {
            binder << getValueOfExpiresIn();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[5])
    {
        if(getRedirectUri())
        {
            binder << getValueOfRedirectUri();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[6])
    {
        if(getCreatedAt())
        {
            binder << getValueOfCreatedAt();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[7])
    {
        if(getRevokedAt())
        {
            binder << getValueOfRevokedAt();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[8])
    {
        if(getScopes())
        {
            binder << getValueOfScopes();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[9])
    {
        if(getCodeChallenge())
        {
            binder << getValueOfCodeChallenge();
        }
        else
        {
            binder << nullptr;
        }
    }
    if(_dirtyFlag[10])
    {
        if(getCodeChallengeMethod())
        {
            binder << getValueOfCodeChallengeMethod();
        }
        else
        {
            binder << nullptr;
        }
    }
}
Json::Value OauthAccessGrants::toJson() const
{
    Json::Value ret;
    if(getId())
    {
        ret["id"]=(Json::Int64)getValueOfId();
    }
    else
    {
        ret["id"]=Json::Value();
    }
    if(getResourceOwnerId())
    {
        ret["resource_owner_id"]=(Json::Int64)getValueOfResourceOwnerId();
    }
    else
    {
        ret["resource_owner_id"]=Json::Value();
    }
    if(getApplicationId())
    {
        ret["application_id"]=(Json::Int64)getValueOfApplicationId();
    }
    else
    {
        ret["application_id"]=Json::Value();
    }
    if(getToken())
    {
        ret["token"]=getValueOfToken();
    }
    else
    {
        ret["token"]=Json::Value();
    }
    if(getExpiresIn())
    {
        ret["expires_in"]=getValueOfExpiresIn();
    }
    else
    {
        ret["expires_in"]=Json::Value();
    }
    if(getRedirectUri())
    {
        ret["redirect_uri"]=getValueOfRedirectUri();
    }
    else
    {
        ret["redirect_uri"]=Json::Value();
    }
    if(getCreatedAt())
    {
        ret["created_at"]=getCreatedAt()->toDbStringLocal();
    }
    else
    {
        ret["created_at"]=Json::Value();
    }
    if(getRevokedAt())
    {
        ret["revoked_at"]=getRevokedAt()->toDbStringLocal();
    }
    else
    {
        ret["revoked_at"]=Json::Value();
    }
    if(getScopes())
    {
        ret["scopes"]=getValueOfScopes();
    }
    else
    {
        ret["scopes"]=Json::Value();
    }
    if(getCodeChallenge())
    {
        ret["code_challenge"]=getValueOfCodeChallenge();
    }
    else
    {
        ret["code_challenge"]=Json::Value();
    }
    if(getCodeChallengeMethod())
    {
        ret["code_challenge_method"]=getValueOfCodeChallengeMethod();
    }
    else
    {
        ret["code_challenge_method"]=Json::Value();
    }
    return ret;
}

Json::Value OauthAccessGrants::toMasqueradedJson(
    const std::vector<std::string> &pMasqueradingVector) const
{
    Json::Value ret;
    if(pMasqueradingVector.size() == 11)
    {
        if(!pMasqueradingVector[0].empty())
        {
            if(getId())
            {
                ret[pMasqueradingVector[0]]=(Json::Int64)getValueOfId();
            }
            else
            {
                ret[pMasqueradingVector[0]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[1].empty())
        {
            if(getResourceOwnerId())
            {
                ret[pMasqueradingVector[1]]=(Json::Int64)getValueOfResourceOwnerId();
            }
            else
            {
                ret[pMasqueradingVector[1]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[2].empty())
        {
            if(getApplicationId())
            {
                ret[pMasqueradingVector[2]]=(Json::Int64)getValueOfApplicationId();
            }
            else
            {
                ret[pMasqueradingVector[2]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[3].empty())
        {
            if(getToken())
            {
                ret[pMasqueradingVector[3]]=getValueOfToken();
            }
            else
            {
                ret[pMasqueradingVector[3]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[4].empty())
        {
            if(getExpiresIn())
            {
                ret[pMasqueradingVector[4]]=getValueOfExpiresIn();
            }
            else
            {
                ret[pMasqueradingVector[4]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[5].empty())
        {
            if(getRedirectUri())
            {
                ret[pMasqueradingVector[5]]=getValueOfRedirectUri();
            }
            else
            {
                ret[pMasqueradingVector[5]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[6].empty())
        {
            if(getCreatedAt())
            {
                ret[pMasqueradingVector[6]]=getCreatedAt()->toDbStringLocal();
            }
            else
            {
                ret[pMasqueradingVector[6]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[7].empty())
        {
            if(getRevokedAt())
            {
                ret[pMasqueradingVector[7]]=getRevokedAt()->toDbStringLocal();
            }
            else
            {
                ret[pMasqueradingVector[7]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[8].empty())
        {
            if(getScopes())
            {
                ret[pMasqueradingVector[8]]=getValueOfScopes();
            }
            else
            {
                ret[pMasqueradingVector[8]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[9].empty())
        {
            if(getCodeChallenge())
            {
                ret[pMasqueradingVector[9]]=getValueOfCodeChallenge();
            }
            else
            {
                ret[pMasqueradingVector[9]]=Json::Value();
            }
        }
        if(!pMasqueradingVector[10].empty())
        {
            if(getCodeChallengeMethod())
            {
                ret[pMasqueradingVector[10]]=getValueOfCodeChallengeMethod();
            }
            else
            {
                ret[pMasqueradingVector[10]]=Json::Value();
            }
        }
        return ret;
    }
    LOG_ERROR << "Masquerade failed";
    if(getId())
    {
        ret["id"]=(Json::Int64)getValueOfId();
    }
    else
    {
        ret["id"]=Json::Value();
    }
    if(getResourceOwnerId())
    {
        ret["resource_owner_id"]=(Json::Int64)getValueOfResourceOwnerId();
    }
    else
    {
        ret["resource_owner_id"]=Json::Value();
    }
    if(getApplicationId())
    {
        ret["application_id"]=(Json::Int64)getValueOfApplicationId();
    }
    else
    {
        ret["application_id"]=Json::Value();
    }
    if(getToken())
    {
        ret["token"]=getValueOfToken();
    }
    else
    {
        ret["token"]=Json::Value();
    }
    if(getExpiresIn())
    {
        ret["expires_in"]=getValueOfExpiresIn();
    }
    else
    {
        ret["expires_in"]=Json::Value();
    }
    if(getRedirectUri())
    {
        ret["redirect_uri"]=getValueOfRedirectUri();
    }
    else
    {
        ret["redirect_uri"]=Json::Value();
    }
    if(getCreatedAt())
    {
        ret["created_at"]=getCreatedAt()->toDbStringLocal();
    }
    else
    {
        ret["created_at"]=Json::Value();
    }
    if(getRevokedAt())
    {
        ret["revoked_at"]=getRevokedAt()->toDbStringLocal();
    }
    else
    {
        ret["revoked_at"]=Json::Value();
    }
    if(getScopes())
    {
        ret["scopes"]=getValueOfScopes();
    }
    else
    {
        ret["scopes"]=Json::Value();
    }
    if(getCodeChallenge())
    {
        ret["code_challenge"]=getValueOfCodeChallenge();
    }
    else
    {
        ret["code_challenge"]=Json::Value();
    }
    if(getCodeChallengeMethod())
    {
        ret["code_challenge_method"]=getValueOfCodeChallengeMethod();
    }
    else
    {
        ret["code_challenge_method"]=Json::Value();
    }
    return ret;
}

bool OauthAccessGrants::validateJsonForCreation(const Json::Value &pJson, std::string &err)
{
    if(pJson.isMember("id"))
    {
        if(!validJsonOfField(0, "id", pJson["id"], err, true))
            return false;
    }
    if(pJson.isMember("resource_owner_id"))
    {
        if(!validJsonOfField(1, "resource_owner_id", pJson["resource_owner_id"], err, true))
            return false;
    }
    else
    {
        err="The resource_owner_id column cannot be null";
        return false;
    }
    if(pJson.isMember("application_id"))
    {
        if(!validJsonOfField(2, "application_id", pJson["application_id"], err, true))
            return false;
    }
    else
    {
        err="The application_id column cannot be null";
        return false;
    }
    if(pJson.isMember("token"))
    {
        if(!validJsonOfField(3, "token", pJson["token"], err, true))
            return false;
    }
    else
    {
        err="The token column cannot be null";
        return false;
    }
    if(pJson.isMember("expires_in"))
    {
        if(!validJsonOfField(4, "expires_in", pJson["expires_in"], err, true))
            return false;
    }
    else
    {
        err="The expires_in column cannot be null";
        return false;
    }
    if(pJson.isMember("redirect_uri"))
    {
        if(!validJsonOfField(5, "redirect_uri", pJson["redirect_uri"], err, true))
            return false;
    }
    else
    {
        err="The redirect_uri column cannot be null";
        return false;
    }
    if(pJson.isMember("created_at"))
    {
        if(!validJsonOfField(6, "created_at", pJson["created_at"], err, true))
            return false;
    }
    else
    {
        err="The created_at column cannot be null";
        return false;
    }
    if(pJson.isMember("revoked_at"))
    {
        if(!validJsonOfField(7, "revoked_at", pJson["revoked_at"], err, true))
            return false;
    }
    if(pJson.isMember("scopes"))
    {
        if(!validJsonOfField(8, "scopes", pJson["scopes"], err, true))
            return false;
    }
    if(pJson.isMember("code_challenge"))
    {
        if(!validJsonOfField(9, "code_challenge", pJson["code_challenge"], err, true))
            return false;
    }
    if(pJson.isMember("code_challenge_method"))
    {
        if(!validJsonOfField(10, "code_challenge_method", pJson["code_challenge_method"], err, true))
            return false;
    }
    return true;
}
bool OauthAccessGrants::validateMasqueradedJsonForCreation(const Json::Value &pJson,
                                                           const std::vector<std::string> &pMasqueradingVector,
                                                           std::string &err)
{
    if(pMasqueradingVector.size() != 11)
    {
        err = "Bad masquerading vector";
        return false;
    }
    if(!pMasqueradingVector[0].empty())
    {
        if(pJson.isMember(pMasqueradingVector[0]))
        {
            if(!validJsonOfField(0, pMasqueradingVector[0], pJson[pMasqueradingVector[0]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[1].empty())
    {
        if(pJson.isMember(pMasqueradingVector[1]))
        {
            if(!validJsonOfField(1, pMasqueradingVector[1], pJson[pMasqueradingVector[1]], err, true))
                return false;
        }
        else
        {
            err="The " + pMasqueradingVector[1] + " column cannot be null";
            return false;
        }
    }
    if(!pMasqueradingVector[2].empty())
    {
        if(pJson.isMember(pMasqueradingVector[2]))
        {
            if(!validJsonOfField(2, pMasqueradingVector[2], pJson[pMasqueradingVector[2]], err, true))
                return false;
        }
        else
        {
            err="The " + pMasqueradingVector[2] + " column cannot be null";
            return false;
        }
    }
    if(!pMasqueradingVector[3].empty())
    {
        if(pJson.isMember(pMasqueradingVector[3]))
        {
            if(!validJsonOfField(3, pMasqueradingVector[3], pJson[pMasqueradingVector[3]], err, true))
                return false;
        }
        else
        {
            err="The " + pMasqueradingVector[3] + " column cannot be null";
            return false;
        }
    }
    if(!pMasqueradingVector[4].empty())
    {
        if(pJson.isMember(pMasqueradingVector[4]))
        {
            if(!validJsonOfField(4, pMasqueradingVector[4], pJson[pMasqueradingVector[4]], err, true))
                return false;
        }
        else
        {
            err="The " + pMasqueradingVector[4] + " column cannot be null";
            return false;
        }
    }
    if(!pMasqueradingVector[5].empty())
    {
        if(pJson.isMember(pMasqueradingVector[5]))
        {
            if(!validJsonOfField(5, pMasqueradingVector[5], pJson[pMasqueradingVector[5]], err, true))
                return false;
        }
        else
        {
            err="The " + pMasqueradingVector[5] + " column cannot be null";
            return false;
        }
    }
    if(!pMasqueradingVector[6].empty())
    {
        if(pJson.isMember(pMasqueradingVector[6]))
        {
            if(!validJsonOfField(6, pMasqueradingVector[6], pJson[pMasqueradingVector[6]], err, true))
                return false;
        }
        else
        {
            err="The " + pMasqueradingVector[6] + " column cannot be null";
            return false;
        }
    }
    if(!pMasqueradingVector[7].empty())
    {
        if(pJson.isMember(pMasqueradingVector[7]))
        {
            if(!validJsonOfField(7, pMasqueradingVector[7], pJson[pMasqueradingVector[7]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[8].empty())
    {
        if(pJson.isMember(pMasqueradingVector[8]))
        {
            if(!validJsonOfField(8, pMasqueradingVector[8], pJson[pMasqueradingVector[8]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[9].empty())
    {
        if(pJson.isMember(pMasqueradingVector[9]))
        {
            if(!validJsonOfField(9, pMasqueradingVector[9], pJson[pMasqueradingVector[9]], err, true))
                return false;
        }
    }
    if(!pMasqueradingVector[10].empty())
    {
        if(pJson.isMember(pMasqueradingVector[10]))
        {
            if(!validJsonOfField(10, pMasqueradingVector[10], pJson[pMasqueradingVector[10]], err, true))
                return false;
        }
    }
    return true;
}
bool OauthAccessGrants::validateJsonForUpdate(const Json::Value &pJson, std::string &err)
{
    if(pJson.isMember("id"))
    {
        if(!validJsonOfField(0, "id", pJson["id"], err, false))
            return false;
    }
    else
    {
        err = "The value of primary key must be set in the json object for update";
        return false;
    }
    if(pJson.isMember("resource_owner_id"))
    {
        if(!validJsonOfField(1, "resource_owner_id", pJson["resource_owner_id"], err, false))
            return false;
    }
    if(pJson.isMember("application_id"))
    {
        if(!validJsonOfField(2, "application_id", pJson["application_id"], err, false))
            return false;
    }
    if(pJson.isMember("token"))
    {
        if(!validJsonOfField(3, "token", pJson["token"], err, false))
            return false;
    }
    if(pJson.isMember("expires_in"))
    {
        if(!validJsonOfField(4, "expires_in", pJson["expires_in"], err, false))
            return false;
    }
    if(pJson.isMember("redirect_uri"))
    {
        if(!validJsonOfField(5, "redirect_uri", pJson["redirect_uri"], err, false))
            return false;
    }
    if(pJson.isMember("created_at"))
    {
        if(!validJsonOfField(6, "created_at", pJson["created_at"], err, false))
            return false;
    }
    if(pJson.isMember("revoked_at"))
    {
        if(!validJsonOfField(7, "revoked_at", pJson["revoked_at"], err, false))
            return false;
    }
    if(pJson.isMember("scopes"))
    {
        if(!validJsonOfField(8, "scopes", pJson["scopes"], err, false))
            return false;
    }
    if(pJson.isMember("code_challenge"))
    {
        if(!validJsonOfField(9, "code_challenge", pJson["code_challenge"], err, false))
            return false;
    }
    if(pJson.isMember("code_challenge_method"))
    {
        if(!validJsonOfField(10, "code_challenge_method", pJson["code_challenge_method"], err, false))
            return false;
    }
    return true;
}
bool OauthAccessGrants::validateMasqueradedJsonForUpdate(const Json::Value &pJson,
                                                         const std::vector<std::string> &pMasqueradingVector,
                                                         std::string &err)
{
    if(pMasqueradingVector.size() != 11)
    {
        err = "Bad masquerading vector";
        return false;
    }
    if(!pMasqueradingVector[0].empty() && pJson.isMember(pMasqueradingVector[0]))
    {
        if(!validJsonOfField(0, pMasqueradingVector[0], pJson[pMasqueradingVector[0]], err, false))
            return false;
    }
    else
    {
        err = "The value of primary key must be set in the json object for update";
        return false;
    }
    if(!pMasqueradingVector[1].empty() && pJson.isMember(pMasqueradingVector[1]))
    {
        if(!validJsonOfField(1, pMasqueradingVector[1], pJson[pMasqueradingVector[1]], err, false))
            return false;
    }
    if(!pMasqueradingVector[2].empty() && pJson.isMember(pMasqueradingVector[2]))
    {
        if(!validJsonOfField(2, pMasqueradingVector[2], pJson[pMasqueradingVector[2]], err, false))
            return false;
    }
    if(!pMasqueradingVector[3].empty() && pJson.isMember(pMasqueradingVector[3]))
    {
        if(!validJsonOfField(3, pMasqueradingVector[3], pJson[pMasqueradingVector[3]], err, false))
            return false;
    }
    if(!pMasqueradingVector[4].empty() && pJson.isMember(pMasqueradingVector[4]))
    {
        if(!validJsonOfField(4, pMasqueradingVector[4], pJson[pMasqueradingVector[4]], err, false))
            return false;
    }
    if(!pMasqueradingVector[5].empty() && pJson.isMember(pMasqueradingVector[5]))
    {
        if(!validJsonOfField(5, pMasqueradingVector[5], pJson[pMasqueradingVector[5]], err, false))
            return false;
    }
    if(!pMasqueradingVector[6].empty() && pJson.isMember(pMasqueradingVector[6]))
    {
        if(!validJsonOfField(6, pMasqueradingVector[6], pJson[pMasqueradingVector[6]], err, false))
            return false;
    }
    if(!pMasqueradingVector[7].empty() && pJson.isMember(pMasqueradingVector[7]))
    {
        if(!validJsonOfField(7, pMasqueradingVector[7], pJson[pMasqueradingVector[7]], err, false))
            return false;
    }
    if(!pMasqueradingVector[8].empty() && pJson.isMember(pMasqueradingVector[8]))
    {
        if(!validJsonOfField(8, pMasqueradingVector[8], pJson[pMasqueradingVector[8]], err, false))
            return false;
    }
    if(!pMasqueradingVector[9].empty() && pJson.isMember(pMasqueradingVector[9]))
    {
        if(!validJsonOfField(9, pMasqueradingVector[9], pJson[pMasqueradingVector[9]], err, false))
            return false;
    }
    if(!pMasqueradingVector[10].empty() && pJson.isMember(pMasqueradingVector[10]))
    {
        if(!validJsonOfField(10, pMasqueradingVector[10], pJson[pMasqueradingVector[10]], err, false))
            return false;
    }
    return true;
}
bool OauthAccessGrants::validJsonOfField(size_t index,
                                         const std::string &fieldName,
                                         const Json::Value &pJson, 
                                         std::string &err, 
                                         bool isForCreation)
{
    switch(index)
    {
        case 0:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(isForCreation)
            {
                err="The automatic primary key cannot be set";
                return false;
            }        
            if(!pJson.isInt64())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 1:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt64())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 2:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt64())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 3:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isString() && !pJson.isNull())
            {
                err="Type error in the "+fieldName+"field";
                return false;                
            }
            break;
        case 4:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isInt())
            {
                err="Type error in the "+fieldName+"field";
                return false;
            }
            break;
        case 5:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isString() && !pJson.isNull())
            {
                err="Type error in the "+fieldName+"field";
                return false;                
            }
            break;
        case 6:
            if(pJson.isNull())
            {
                err="The " + fieldName + " column cannot be null";
                return false;
            }
            if(!pJson.isString() && !pJson.isNull())
            {
                err="Type error in the "+fieldName+"field";
                return false;                
            }
            break;
        case 7:
            if(!pJson.isString() && !pJson.isNull())
            {
                err="Type error in the "+fieldName+"field";
                return false;                
            }
            break;
        case 8:
            if(!pJson.isString() && !pJson.isNull())
            {
                err="Type error in the "+fieldName+"field";
                return false;                
            }
            break;
        case 9:
            if(!pJson.isString() && !pJson.isNull())
            {
                err="Type error in the "+fieldName+"field";
                return false;                
            }
            break;
        case 10:
            if(!pJson.isString() && !pJson.isNull())
            {
                err="Type error in the "+fieldName+"field";
                return false;                
            }
            break;
     
        default:
            err="Internal error in the server";
            return false;
            break;
    }
    return true;
}
